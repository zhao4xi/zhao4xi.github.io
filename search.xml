<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>aop的原理探究</title>
      <link href="/2019/09/17/aop%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
      <url>/2019/09/17/aop%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>aop的概念时常提起, 但是没有在实际场景中使用, 最近有机会在实际场景中运用, 这里深入的记录一下探索过程.</p><h2 id="aop-的分类"><a href="#aop-的分类" class="headerlink" title="aop 的分类"></a>aop 的分类</h2><p>aop 全称: Aspect Oriented Programming , 即面向切面编程, 是在编译时或者运行时为某一个切点(一般是方法)添加统一的功能的一种编码方式.</p><blockquote><p>编译时AOP(静态织入), 常见的框架 PostSharp(主流用法, 基于mono.cicel + MSbuild, 也可以运行时AOP)<br>运行时AOP(动态代理), 常见框架 Castle, 主流 IOC 框架实现代理</p></blockquote><h2 id="编译时AOP"><a href="#编译时AOP" class="headerlink" title="编译时AOP"></a>编译时AOP</h2><p>根据名称可以知道, 这个过程发生在dll编译的时候. 编译时AOP是将织入的方法通过IL的方式直接写入编译的dll中. 这一点通过反编译postsharp 等工具的生成dll 可知<br><strong>优点</strong>: 整体效率比运行时要高, 功能强大.<br><strong>缺点</strong>: 修改代码需要重新通过专门的编译器编译, 操作相对复杂.</p><h2 id="运行时AOP"><a href="#运行时AOP" class="headerlink" title="运行时AOP"></a>运行时AOP</h2><p>通常使用系统自带的反射机制或者第三方IOC框架在运行时动态执行需要织入的方法.<br><strong>优点</strong>: 核心思想和使用都比较简单<br><strong>缺点</strong>: 性能略低, 一般只适合方法的调用.<br>下面使用.net Remoting 来实现一个简单的 aop 功能</p><pre><code class="csharp">    static void Main(string[] args)    {        var service = TinyAop.Create&lt;IServiceA, ServiceA&gt;(new LogInterceptor(), new ErrorInterceptor());        service.Say(&quot;hello world&quot;);        service.Error();        Console.Read();    }    interface IServiceA { void Say(string word); void Error(); }    public class ServiceA : IServiceA    {          public void Error()        {            throw new Exception(&quot;出错啦&quot;);        }        public void Say(string word)        {            Console.WriteLine(word);        }    }    class LogInterceptor : Interceptor    {        public void Invoke(Invocation invocation)        {            try            {                Console.WriteLine(&quot;before log&quot;);                invocation.Proceed();                Console.WriteLine(&quot;after log&quot;);            }            catch (Exception ex)            {                Console.WriteLine(ex.InnerException);                invocation.ReturnValue = &quot;出错啦&quot;;            }        }    }    class ErrorInterceptor : Interceptor    {        public void Invoke(Invocation invocation)        {            try            {                invocation.Proceed();            }            catch (Exception ex)            {                invocation.ReturnValue = &quot;出错啦&quot;;                Console.WriteLine(ex.InnerException);            }        }    }    class TinyAop    {        public static T Create&lt;IT, T&gt;(params Interceptor[] interceptors)        {            T instance = Activator.CreateInstance&lt;T&gt;();            RealProxyEx&lt;T&gt; realProxy = new RealProxyEx&lt;T&gt;(instance, interceptors);            T transparentProxy = (T)realProxy.GetTransparentProxy();            return transparentProxy;        }    }    class RealProxyEx&lt;T&gt; : RealProxy    {        private object _target;        private Interceptor[] _interceptors;        public RealProxyEx(object target, Interceptor[] interceptors) : base(typeof(T))        {            _target = target;            _interceptors = interceptors;        }        public override IMessage Invoke(IMessage msg)        {            Invocation invocation = new Invocation(msg, _target);            if (_interceptors != null &amp;&amp; _interceptors.Length &gt; 0)            {                foreach (var item in _interceptors)                {                    item.Invoke(invocation);                }            }            else            {                invocation.Proceed();            }            return new ReturnMessage(invocation.ReturnValue, new object[0], 0, null, invocation.CallMessage);        }    }    class Invocation    {        public MethodBase Method { get; set; }        public object ReturnValue { get; set; }        public IMethodCallMessage CallMessage =&gt; (IMethodCallMessage)_msg;        private IMessage _msg;        private object _target;        public Invocation(IMessage msg, object target)        {            _target = target;            _msg = msg;        }        public void Proceed()        {            IMethodCallMessage callMessage = (IMethodCallMessage)_msg;            Method = callMessage.MethodBase;            ReturnValue = Method.Invoke(_target, callMessage.Args);        }    }    interface Interceptor    {        void Invoke(Invocation invocation);    }</code></pre><h2 id="隔壁spring框架中的类比"><a href="#隔壁spring框架中的类比" class="headerlink" title="隔壁spring框架中的类比"></a>隔壁spring框架中的类比</h2><blockquote><p>编译时: AspectJ<br>运行时: jdk(一般代理接口), cglib (代理(重写)实现类)</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AOP的思想比如何使用更重要, 仔细学习看看, 其实很简单.</p><h3 id="代码托管地址"><a href="#代码托管地址" class="headerlink" title="代码托管地址"></a><a href="https://github.com/zhao4xi/TinyIocAndAop" target="_blank" rel="noopener">代码托管地址</a></h3>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ioc循环依赖的发现与解决</title>
      <link href="/2019/09/16/ioc%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/09/16/ioc%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在重构代码, 为框架添加Autofac作为ioc容器, 在处理业务层时, 遇到不同Service相互依赖的问题, 俗称循环依赖. 后来经过讨论解决了这个问题, 这里记录一下我们的探索过程.</p><h2 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h2><p>A服务依赖于B服务作为构造函数的参数, B服务依赖于A服务作为构造函数的参数, demo代码如下:</p><pre><code class="csharp">    public class ServiceA : IServiceA    {        private readonly IServiceB _serviceB;        public ServiceA(IServiceB serviceB)        {            _serviceB = serviceB;        }    }    public interface IServiceA {}    public class ServiceB : IServiceB    {        private readonly IServiceA _serviceA;        public ServiceB(IServiceA serviceA)        {            _serviceA = serviceA;        }    }    public interface IServiceB {}</code></pre><h2 id="第一次讨论"><a href="#第一次讨论" class="headerlink" title="第一次讨论"></a>第一次讨论</h2><p>因为.net中通常使用构造函数注入, 如果出现循环依赖, 那么第一步考虑的就是拆分服务A或者服务B, 将互调部分拆分出一个服务AB, 专门处理互调业务. demo代码:</p><pre><code class="csharp">    public class ServiceAB : IServiceAB    {        private readonly IServiceA _serviceA;        private readonly IServiceB _serviceB;        public ServiceB(IServiceA serviceA, IServiceB serviceB)        {            _serviceA = serviceA;            _serviceB = serviceB;        }    }    public interface IServiceAB {}</code></pre><p><strong>优点</strong>: 每个服务的作用比较独立和内聚, 也很简单的解决了循环依赖的问题.<br><strong>缺点</strong>: 在实际操作中拆分的规则和粒度很难把握, 会增加一些重复代码.</p><h2 id="讨论后的探索"><a href="#讨论后的探索" class="headerlink" title="讨论后的探索"></a>讨论后的探索</h2><p>因为Spring中使用常用注解[AutoWired]来进行注入, 且使用的是字段注入, 不会存在循环依赖的问题, 所以探索在Autofac中是否可以使用属性注入来解决这个问题, 尝试后发现可行, demo代码:</p><pre><code class="csharp">    public class ServiceA : IServiceA    {        [AutofacInject]        public IServiceB ServiceBImp {get; set;}    }    public class ServiceB : IServiceB    {        [AutofacInject]        public IServiceA ServiceAImp {get; set;}    }    //注入方式, Autofac 版本4.6.2    builder.RegisterType&lt;ServiceB&gt;().As&lt;IServiceB&gt;().SingleInstance().PropertiesAutowired(new PropertySelector(), true);    builder.RegisterType&lt;ServiceA&gt;().As&lt;IServiceA&gt;().SingleInstance().PropertiesAutowired(new PropertySelector(), true);    /// &lt;summary&gt;    /// Autofac 是否自动注入特性     /// &lt;/summary&gt;    public class AutofacInjectAttribute : Attribute    {        public bool Inject { get; set; } = true;         public AutofacInjectAttribute(bool inject = true)        {            Inject = inject;        }    }    public class PropertySelector : IPropertySelector    {        public bool InjectProperty(PropertyInfo propertyInfo, object instance)        {            var autofacInjectAttr = propertyInfo.GetCustomAttributes().FirstOrDefault(p =&gt; p.GetType() == typeof(AutofacInjectAttribute)) as AutofacInjectAttribute;            if (autofacInjectAttr == null)            {                return false;            }            return autofacInjectAttr.Inject;        }    }</code></pre><p>到此为止, 需求已经能完全满足我们的重构, 现在还留下了2个问题需要解决, ioc容器如何发现的循环依赖和属性注入如何解决循环依赖?</p><h2 id="ioc容器如何发现循环依赖"><a href="#ioc容器如何发现循环依赖" class="headerlink" title="ioc容器如何发现循环依赖"></a>ioc容器如何发现循环依赖</h2><p>在Autofac源码中, ResolveOperation.GetOrCreateInstance 方法中找到了答案, 下面是 GetOrCreateInstance的执行过程</p><ol><li>当前递归的层级加1</li><li>判定递归stack是否有循环依赖<ol><li>循环依赖条件1: 递归层级大于等于50</li><li>循环依赖条件2: 递归链上存在当前需要构造的对象</li></ol></li><li>构造对象</li><li>将步骤3构造的对象push到递归stack中</li><li>当前对象构造完成pop递归stack</li><li>递归层级减1</li></ol><pre><code class="csharp">    public object GetOrCreateInstance(ISharingLifetimeScope currentOperationScope, ResolveRequest request)    {        if (_ended) throw new ObjectDisposedException(ResolveOperationResources.TemporaryContextDisposed, innerException: null);        ++_callDepth;        if (_activationStack.Count &gt; 0)            CircularDependencyDetector.CheckForCircularDependency(request.Registration, _activationStack, _callDepth);        var activation = new InstanceLookup(this, currentOperationScope, request);        _activationStack.Push(activation);        var handler = InstanceLookupBeginning;        handler?.Invoke(this, new InstanceLookupBeginningEventArgs(activation));        try        {            var instance = activation.Execute();            _successfulActivations.Add(activation);            return instance;        }        finally        {             _activationStack.Pop();            if (_activationStack.Count == 0)            {                CompleteActivations();            }            --_callDepth;        }    }    public static void CheckForCircularDependency(IComponentRegistration registration, Stack&lt;InstanceLookup&gt; activationStack, int callDepth)    {        if (registration == null) throw new ArgumentNullException(nameof(registration));        if (callDepth &gt; MaxResolveDepth)            throw new DependencyResolutionException(string.Format(CultureInfo.CurrentCulture, CircularDependencyDetectorResources.MaxDepthExceeded, registration));        // Checks for circular dependency        foreach (var a in activationStack)        {            if (a.ComponentRegistration == registration)            {                throw new DependencyResolutionException(string.Format(CultureInfo.CurrentCulture, CircularDependencyDetectorResources.CircularDependency, CreateDependencyGraphTo(registration, activationStack)));            }        }    }</code></pre><h2 id="属性注入如何解决循环依赖"><a href="#属性注入如何解决循环依赖" class="headerlink" title="属性注入如何解决循环依赖"></a>属性注入如何解决循环依赖</h2><p>属性注入的解决依赖的前提: 1. 被循环依赖的属性比如是单例注入的; 2. 允许循环依赖 </p><pre><code class="csharp">    var serviceA = container.Resolve&lt;ServiceA&gt;(); </code></pre><p>下面是单例注入的执行步骤:</p><ol><li>获取ServiceA的实例, 因为注入方式是单例, 所以会缓存ServiceA的对象到_sharedInstances字典中.</li><li>解析ServiceA的属性IServiceB, 尝试从缓存_sharedInstances字典中查找, 如果找到直接赋值给属性并返回.</li><li>如果没有找到, 再构造一个ServiceB的实例缓存到_sharedInstances字典中, 并赋值给属性并返回.</li></ol><h2 id="隔壁Java-Spring如何解决循环依赖"><a href="#隔壁Java-Spring如何解决循环依赖" class="headerlink" title="隔壁Java Spring如何解决循环依赖"></a>隔壁Java Spring如何解决循环依赖</h2><p>核心思想相同, 都是需要缓存并未填充属性的单例对象, earlySingletonObjects 和 _sharedInstances 这两个集合对象的作用相同.</p><ol><li>singletonObject : 用于存放完全初始化好的bean, 从缓存中直接获取</li><li>earlySingletonObjects: 存放原始的bean对象(尚未填充属性), 用于解决循环依赖</li><li>singletonFactories: 存放bean工厂对象, 用于解决循环依赖</li></ol><h2 id="简单的循环依赖IOC处理Demo"><a href="#简单的循环依赖IOC处理Demo" class="headerlink" title="简单的循环依赖IOC处理Demo"></a>简单的循环依赖IOC处理Demo</h2><pre><code class="csharp">    static void Main(string[] args)    {        TinyIoc.Register&lt;IServiceA, ServiceA&gt;();        TinyIoc.Register&lt;IServiceB, ServiceB&gt;();                var serviceA = TinyIoc.GetByProp&lt;IServiceA&gt;();    }    class TinyIoc    {        private static Dictionary&lt;Type, Type&gt; _typeImplDic = new Dictionary&lt;Type, Type&gt;();        private static Dictionary&lt;Type, object&gt; _instanceTypeDic = new Dictionary&lt;Type, object&gt;(); // singletonObject        private static Dictionary&lt;Type, object&gt; _earlyInstanceTypeDic = new Dictionary&lt;Type, object&gt;(); // earlySingletonObjects        public static object GetByProp(Type typeofT)        {            if (_instanceTypeDic.ContainsKey(typeofT))             {                return _instanceTypeDic[typeofT];            }            if (_earlyInstanceTypeDic.ContainsKey(typeofT))            {                return _earlyInstanceTypeDic[typeofT];            }            var typeImp = _typeImplDic[typeofT];            var impObj = Activator.CreateInstance(typeImp); //singletonFactories             _earlyInstanceTypeDic.Add(typeofT, impObj);            var propes = typeImp.GetProperties();            foreach (var item in propes)            {                item.SetValue(impObj, GetByProp(item.PropertyType));            }            _instanceTypeDic.Add(typeofT, typeImp);            return impObj;        }        public static T GetByProp&lt;T&gt;()        {            var typeofT = typeof(T);            return (T)GetByProp(typeofT);        }        public static void Register&lt;IT, T&gt;()        {            _typeImplDic.Add(typeof(IT), typeof(T));        }     } </code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习使我快落</p><h3 id="代码托管地址"><a href="#代码托管地址" class="headerlink" title="代码托管地址"></a><a href="https://github.com/zhao4xi/TinyIocAndAop" target="_blank" rel="noopener">代码托管地址</a></h3>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ioc </tag>
            
            <tag> 循环依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https和http的区别与比较</title>
      <link href="/2019/01/28/https%E5%92%8Chttp%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E6%AF%94%E8%BE%83/"/>
      <url>/2019/01/28/https%E5%92%8Chttp%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>是一个基于tcp/ip的应用层的的请求/响应式协议, 全称超文本传输协议.<br>特点: </p><ol><li>简单快速灵活, 常用方式 Post Get Put Delete , 支持多种传输数据类型</li><li>无状态, 多次请求没有状态保持</li><li>无连接, 每次处理一个请求</li><li>端口 80<br>不加密的, 任何内容都可能被伪装或者篡改</li></ol><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>https = http + ssl加密 + 认证 + 完整性保护<br>https就是将http与tcp通信中层添加了一个ssl/tsl加密变成 http-&gt;ssl/tsl-&gt;tcp</p><p>特点:</p><ol><li>继承了http的所有特点</li><li>接口层使用了http和tcp直接新增了ssl/tsl协议(tsl 是 ssl 标准化后的名字)</li><li>因为ssl/tsl (引入了 证书/私钥/公钥)加密会耗费服务器资源, 所以默认提供http.</li><li>端口443<br>加密, 相对http较安全</li></ol><h2 id="SSL-TSL-传输层安全协议"><a href="#SSL-TSL-传输层安全协议" class="headerlink" title="SSL(TSL 传输层安全协议)"></a>SSL(TSL 传输层安全协议)</h2><p>安全套接层 基于 应用层和TCP层协议之间, 为数据通信提供安全组支持.<br>主要工作流程:</p><ol><li>客户端想服务器索要公钥<ol><li>判定公钥的证书是否由受信任的CA机构签发,是否有效等, 不是提示警告</li></ol></li><li>使用公钥加密一个随机值(私钥)发送给服务端</li><li>服务端使用私钥解密保存这个随机值, 双方基于这个随机值进行对称加密通信</li><li>服务器端使用随机值加密返回数据</li><li>客户端使用随机值解密<br>简化过程就是:</li><li>客户端向服务器端索要并验证公钥</li><li>双方协商生成”回话秘钥”</li><li>双方采用”回话秘钥”进行加密通信</li></ol><h2 id="总结区别"><a href="#总结区别" class="headerlink" title="总结区别"></a>总结区别</h2><ol><li>http 连接简单, 无状态, 明文传输; https 由SSL+http构建加密传输+ 身份认证, 比较安全, 但由于加密的缘故, 所以相对耗费资源.</li><li>http 和 https 连接方式不一致, http默认使用80端口, https使用443端口.</li><li>https 协议确认到ca证书, 需要一定费用.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP的三次握手和四次挥手</title>
      <link href="/2019/01/05/TCP-IP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2019/01/05/TCP-IP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>tcp/ip 握手挥手是网络连接的基本知识, 值的花时间弄懂到底干了什么.</p><h2 id="TCP-IP-协议分层"><a href="#TCP-IP-协议分层" class="headerlink" title="TCP/IP 协议分层"></a>TCP/IP 协议分层</h2><pre><code>OSI参考模型| TCP/IP参考模型</code></pre><ol start="7"><li>应用层                |    </li><li>表示层                |  4. 应用层(ftp、http、dns、telnet、smtp…)</li><li>会话层                 |</li><li>运输层               |   3. 运输层(tcp,udp)</li><li>网络层               |   2. 网络层(ip、icmp、arp、rarp、bootp)</li><li>数据链路层        |   1. 网络接口层   </li><li>物理层               |     </li></ol><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>TCP 在发送过程中, 会借助一个TCP标志选项来确定当前TCP段的目的, 这就叫着TCP标志位(TCP Flag), 告诉另一端如何正确使用该TCP段.<br>TCP 一共有6 个标志选项</p><ol><li>Urgent pointer : 紧急指针, 接收端接收到紧急指针后立即处理, 不经过等待队列.</li><li>Acknowledgement : 确认, 确认数据包的成功接收.</li><li>Push : 推送. 给与数据优先级, 确保在接收端处理.</li><li>RST: 复位. 服务端无法答复客户端的请求时, 会拒绝请求并发送复位.</li><li>Synchronisation : 同步, 连接三次握手时, 由于建立虚拟连接而使用的标志.</li><li>Fin : 完成, 拆除上一次(SYN) 简历的虚拟连接,一般是四次挥手时使用的标志.<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2>客户端 : 发起第一次请求, 发送 Seq num = N , 标志位 : SYN ,  状态变更为: SYN_SENT<br>服务端 : 发起第二次请求, 发送 Seq num = M, Ack num = N + 1, 标志位 : SYN , ACK  , 状态变更为: SYN_RVCD<br>客户端 : 发起第三次请求, 发送 Seq num = N + 1, Ack num = M + 1, 标志位 : ACK , 状态变更为: ESTABLISHED<br>握手完成, 开始正常通信<br>服务端 : 建立连接 状态变更为 ESTABLISHED<br><img src="/.io//three.png" alt="在这里插入图片描述"><br>使用大白话讲解就是:<br>A: 你能听的到我说话吗?<br>B: 我能听到你说话, 那你能听到我说话吗?<br>A: 我能听到你说话, 那我们开始交流吧</li></ol><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>客户端 : 发起第一次请求, 发送 Seq num = N, 标志位 : FIN , 状态变更为 : FIN-WAIT-1<br>服务端 : 发起第二次请求, 发送 Seq num = L, Ack num  = N + 1 , 标志位 : ACK , 状态变更为 : CLOSE-WAIT<br>服务端 : 发起第三次请求, 发送 Seq num = M, Ack num  = N + 1 , 标志位 : FIN , ACK , 状态变更为 : LAST-ACK<br>客户端 : 发起第四次请求, 发送 Seq num = N + 1, Ack num  = M + 1 , 标志位 : ACK , 状态变更为 : TIME-WAIT<br>挥手完成, 所有连接关闭, 状态变更为 CLOSED<br><img src="/.io//four.png" alt="在这里插入图片描述"><br> 使用大白话讲解就是:<br>A: 注意我要准备挂电话了<br>B: 我知道你要挂电话了, 但是我还要说些没有说完的内容.<br>B: 我也要准备挂电话了.<br>A: 我已经知道你要挂电话了, 我挂了, ByeBye.</p>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 事务</title>
      <link href="/2019/01/05/Spring-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2019/01/05/Spring-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h2><p>单个逻辑工作单元执行的一系列操作, 这一系列操作要么全部执行, 要么全部不执行.<br>从生活示例转账的逻辑来看, A 向 B 转账 100元, 可以分为两步: 1. A 扣款 100 ,2. B 加款 100. 这两步要么全部执行, 要么全部不执行 才是真正完成一次转账. 那么这两步就属于一个事务.</p><h2 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性(ACID)"></a>事务的特性(ACID)</h2><ul><li>原子性(Atomicity) : 事务操作必须是原子工作单元, 对数据修改时, 要么全部执行, 要么全部不执行.</li><li>一致性(Consistency) : 事务操作必须从一个一致性的状态转换到另一个一致性的转台. 例如: 读操作可以读到提交的更新数据; 一个操作读到刚更新的值, 那么后续就不会读到更早更新的值. 这儿的一致性我理解为数据系统状态正常.</li><li>隔离性(Isolation) : 事务执行状态隔离, 不同事务中在执行过程中相互不干扰. 一个事务执行过程中也不会查看另外事务的中间状态数据. </li><li>持久性(Durability) : 事务执行完毕后, 对系统的影响是永久性的. </li></ul><h2 id="Spring-事务管理器"><a href="#Spring-事务管理器" class="headerlink" title="Spring 事务管理器"></a>Spring 事务管理器</h2><p>Spring的事务管理器是由接口 org.springframework.transaction.PlatformTransactionManager 提供的. 它是接口, 所以本身不提供事务管理的能力, 必须有具体的平台 Jdbc, Hibernate, JPA等来提供对应的事务管理器.</p><pre><code class="java">// PlatformTransactionManager 的结构public interface PlatformTransactionManager {    TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException; // 获取TransactionStatus 对象    void commit(TransactionStatus var1) throws TransactionException; // 提交事务    void rollback(TransactionStatus var1) throws TransactionException; // 回滚事务}</code></pre><p>TransactionStatus 提供了事务的状态信息的查询和控制方法. </p><pre><code class="java">public interface TransactionStatus extends SavepointManager, Flushable {    void flush() throws IOException; //  extends Flushable 刷新缓冲区     Object createSavepoint() throws TransactionException; //  extends SavepointManager 创建还原点    void rollbackToSavepoint(Object var1) throws TransactionException;  //  extends SavepointManager 回滚到指定还原点    void releaseSavepoint(Object var1) throws TransactionException;  //  extends SavepointManager 移除指定还原点    boolean isNewTransaction(); // 是否是新的事务    boolean hasSavepoint(); // 是否有还原点    void setRollbackOnly(); // 设置回滚    boolean isRollbackOnly(); // 是否已回滚    void flush(); // extends Flushable    boolean isCompleted(); // 是否已完成}</code></pre><h2 id="Spring-的事务属性定义"><a href="#Spring-的事务属性定义" class="headerlink" title="Spring 的事务属性定义"></a>Spring 的事务属性定义</h2><p>获取一个事务需要传入 TransactionDefinition 对象, 这个接口定义 7 种事务传播行为 和 5 种数据库隔离级别定义.</p><pre><code class="java">public interface TransactionDefinition {    int PROPAGATION_REQUIRED = 0; // 默认值, 如果当前处于一个事务中, 则事务改事务; 否则创建一个新事物    int PROPAGATION_SUPPORTS = 1; // 如果当前处于一个事务中, 则使用该事务; 否则不创建新事务.    int PROPAGATION_MANDATORY = 2; // 如果当前处于一个事务中, 则使用该事务; 否则抛出一个异常.    int PROPAGATION_REQUIRES_NEW = 3; // 强制新开启一个事务, 无论当前是否处于事务中.    int PROPAGATION_NOT_SUPPORTED = 4; // 如果当前处于一个事务中, 则挂起事务以非事务执行; 否则以非事务执行.    int PROPAGATION_NEVER = 5; // 如果当前处于一个事务中, 则抛出异常; 否则以非事务执行.    int PROPAGATION_NESTED = 6; // 嵌套, 当前事务 和 新事务 形成嵌套的事务.    int ISOLATION_DEFAULT = -1; // 默认值 数据库默认的事务隔离级别    int ISOLATION_READ_UNCOMMITTED = 1; // 读未提交    int ISOLATION_READ_COMMITTED = 2; // 读已提交    int ISOLATION_REPEATABLE_READ = 4; // 不可重复读    int ISOLATION_SERIALIZABLE = 8; // 序列化    int TIMEOUT_DEFAULT = -1;     int getPropagationBehavior(); // 获取事务传播行为    int getIsolationLevel(); // 获取数据库隔离级别    int getTimeout();     boolean isReadOnly(); // 是否只读, 一般查询只读, 读写非只读. 一般只读会有优化.    @Nullable    String getName(); // 事务的名称 一般是 save* find* select* ...}</code></pre><p>事务的隔离级别就是为了解决并发过程中的典型问题, 隔离级别从低到高并发性越来越差.</p><ol><li>读脏:  一个事务读到了另外一个事务未提交的数据, 解决方式使用: 读已提交或者更高隔离级别</li><li>不可重复读: 同一个事务中多次读取时每次都读到不同数据. 主要是数据修改</li><li>幻读: 同一个是事务, 多次读取的时候, 可能出现前一次查询不存在的数据或者查询不到前一次已经查询到的数据. 主要是 数据新增和删除.</li></ol><table><thead><tr><th align="left">隔离级别可能会出现的并发问题</th><th align="left">读脏</th><th align="left">不可重复读</th><th align="left">幻读</th></tr></thead><tbody><tr><td align="left">读未提交</td><td align="left">√</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">读已提交</td><td align="left">×</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">不可重复读</td><td align="left">×</td><td align="left">×</td><td align="left">√</td></tr><tr><td align="left">序列化</td><td align="left">×</td><td align="left">×</td><td align="left">×</td></tr></tbody></table><h2 id="常用Spring事务的实现"><a href="#常用Spring事务的实现" class="headerlink" title="常用Spring事务的实现"></a>常用Spring事务的实现</h2><ol><li>使用 @Transaction 注解声明式事务管理.</li></ol><pre><code class="java">// 代表启用事务, 使用数据库默认隔离级别, 默认事务属性@Transactional(isolation=Isolation.DEFAULT,propagation=Propagation.REQUIRED)public void insert(User user){}// 需要在配置事务时启用事务注解&lt;!-- 事务管理器 --&gt;&lt;bean id=&quot;tracnsactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 启用事务注解 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;tracnsactionManager&quot;/&gt; </code></pre><ol start="2"><li>使用 Aspectj AOP配置事务<pre><code class="java">&lt;!-- 事务管理器 --&gt;&lt;bean id=&quot;tracnsactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre></li></ol><p>&lt;tx:advice id=”txAdvice” transaction-manager=”tracnsactionManager”&gt;<br>    <a href="tx:attributes" target="_blank" rel="noopener">tx:attributes</a><br>        &lt;tx:method name=”insert*” isolation=”DEFAULT” propagation=”REQUIRED”/&gt; <!-- 以insert开头的方法使用事务 --><br>    <br> </p><p><a href="aop:config" target="_blank" rel="noopener">aop:config</a><br>    &lt;aop:pointcut expression=”execution(* <em>..service.</em>.*(..))” id=”point”&gt; <!-- 包名为service下所有方法都事务处理 --><br>    &lt;aop:advisor advice-ref=”txAdvice” pointcut-ref=”point”/&gt;<br><br>```</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring 事务实际就是使用依托了 Spring 强大的Aop功能, 将数据库事务封装在框架中, 搞清楚了实现原理, 发现理解起来还是挺简单的.</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis实现分布式锁</title>
      <link href="/2019/01/03/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2019/01/03/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式锁的实现方式很多, 可以使用 数据库乐观锁, 可以适用 Zookeeper, 可以使用Redis, 本文总结一下Redis的分布式锁的常用方式. </p><h2 id="Redis分布式锁的特点"><a href="#Redis分布式锁的特点" class="headerlink" title="Redis分布式锁的特点"></a>Redis分布式锁的特点</h2><ul><li>安全: 在任一时刻, 只有一个客户端持有锁, 同一把锁相互排斥.</li><li>保活1: 无死锁, 持有锁的客户端崩溃或者网络断开, 也可以获取新锁</li><li>保活2: 容错性, 只要大部分Redis节点活着, 客户端就可以正常获取和释放锁</li></ul><h2 id="单个Redis实例实现锁"><a href="#单个Redis实例实现锁" class="headerlink" title="单个Redis实例实现锁"></a>单个Redis实例实现锁</h2><p>单实例下, 假如Redis 服务端稳定运行, 那么下面最简单的实现方式就是: 在Redis中创建Key, 然后这个Key有失效时间, 当客户端在失效时间前释放, 则由客务端发起命令删除Key, 否则等待服务端自动删除Key.<br>该基础算法的命令实现就是</p><pre><code class="redis">set lock_key lock_value NX PX timeout// NX 命令只有不存在 lock_key的时候才会被执行// PX 命令是设置timeout的自动失效时间// 示例: set userId 9527 NX PX 20000  含义就是: 设置一个名称为userId 的key, 它的值是 9527, 超时时间是 20秒.</code></pre><p>使用Jedis模拟上面执行就是下面的代码</p><pre><code class="java">public static void main(String[] args) throws InterruptedException {    Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);    if (lock(jedis, &quot;userId_1&quot;, 1000)) {        System.out.println(&quot;lock first level success&quot;);     // output         if (lock(jedis, &quot;userId_1&quot;, 1000)) {            System.out.println(&quot;lock second level success&quot;);            if (releaseLock(jedis, &quot;userId_1&quot;)) {                System.out.println(&quot;releaseLock second level success&quot;);            } else {                System.out.println(&quot;releaseLock second level fail&quot;);             }        } else {            System.out.println(&quot;lock second level fail&quot;);   // output         }        Thread.sleep(3000);        if (releaseLock(jedis, &quot;userId_1&quot;)) {            System.out.println(&quot;releaseLock one level success&quot;);   // output         } else {            System.out.println(&quot;releaseLock one level fail&quot;);        }    }}public static boolean lock(Jedis jedis, String name, long timeout) {    String result = jedis.set(name, &quot;1&quot;, &quot;NX&quot;, &quot;PX&quot;, timeout);    if (result != null &amp;&amp; result.equals(&quot;OK&quot;)) {        return true;    }    return false;}public static boolean releaseLock(Jedis jedis, String name) {    String result = jedis.get(name);    if (result == null) {        return true;    }    if (result.equals(&quot;1&quot;)) {        jedis.del(name);        return true;    }    return false;}</code></pre><p>但是上面的代码有一个问题, 假如客户端A获取了资源锁, 客户端A操作完毕时去释放锁, 但是锁已经因为超时被Redis自动释放掉了, 并且客户端B 又使用相同的KeyValue加锁, 这个时候客户端A 调用Del命令就删除掉了客户端B的锁, 为了避免这方情况的发生, 就要尽量避免多次加锁时, 使用相同的Key. 这里有两种通用的方式1: 使用 真正业务资源key+ Random 随机生成一个串; 2: 使用 真正业务资源key+毫秒时间戳+客户端编号. 虽然不能保证绝对安全, 但是大部分情况已经足够.</p><h2 id="分布式环境Redis示例实现锁"><a href="#分布式环境Redis示例实现锁" class="headerlink" title="分布式环境Redis示例实现锁"></a>分布式环境Redis示例实现锁</h2><p>假设我们有5个Redis Master节点, 他们完全相互独立, 不存在主从复制和其他集群协调机制, 我们为了取得锁, 可以使用下面的操作</p><ol><li>获取当前毫秒时间戳</li><li>遍历5个客户端, 使用相同的Key,Value获取锁. 设置锁时, 客户端设置一个网络连接和响应超时时间, 该时间小于锁超时时间. 假设 锁自动超时时间是10秒, 则网络超时时间是5-50ms. 这样避免单个服务端挂掉, 影响其他服务端的尝试.</li><li>客户端用当前时间减去1的时间戳就得到锁时间的时间, 当大于3个节点(大多数节点)同时获取锁的时候才算真正的获取锁成功.</li><li>得到了锁之后, key的真实有效时间是锁超时时间减去3中获取锁的时间.</li><li>如果获取锁失败(没有达到3个节点加锁成功或者获取锁的时间已经超过了锁的超时时间), 客户端需要在所有的Redis 示例上解锁. </li></ol><p>释放锁比较简单, 直接删除key就好, 不用关系是否获取成功. </p><p>推荐使用 Redisson 库来直接实现该功能, 具体实现可以参照 <a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">Redisson</a> 库.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了Redis分布式锁官方的推荐做法, 单机和多机部署都有适用. 真正实践还需要更深入的研究.</p><h2 id="引用文献"><a href="#引用文献" class="headerlink" title="引用文献"></a>引用文献</h2><p>官方文档 <a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL实现乐观锁和悲观锁</title>
      <link href="/2019/01/03/Mysql%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
      <url>/2019/01/03/Mysql%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基于数据库的乐观锁和悲观锁主要目的是为了解决在数据库并发时, 对数据更新不一致导致的问题.</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁具有独占和排他两种特性, 修改数据时必须先拿到锁, 否则直接拒绝. 在操作数据的过程中, 全称持有锁, 操作完毕后, 释放锁.</p><h4 id="实现悲观锁"><a href="#实现悲观锁" class="headerlink" title="实现悲观锁"></a>实现悲观锁</h4><p>一般在MySQL中实现悲观锁, 使用 select … for update 实现, 当一个事务对某资源调用了该语句, 其他所有调用该资源的事务只有等待, 直到第一个事务释放.</p><pre><code class="mysql"># 1. 构造测试表CREATE TABLE `test` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(20) NOT NULL,  `age` int(11) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;insert into test (name,age) values(&#39;zhao&#39;,20);insert into test (name,age) values(&#39;xi&#39;,21);# 2. 设置数据库不自动提交set autocommit = 0;# 3. 事务1 执行select * from test where id = 1 for update; # 4. 事务2 执行update test set age = 22 where id = 1;commit;## 可以观察事务2 会一直阻塞在update 语句# 5. 在事务1 执行 commit;## 可以观察事务2 在事务1执行完毕后, 事务2也执行成功.</code></pre><h4 id="for-update-悲观锁的问题"><a href="#for-update-悲观锁的问题" class="headerlink" title="for update 悲观锁的问题"></a>for update 悲观锁的问题</h4><p>当 for update的字段为索引或者主键的时候, 只锁住索引或者主键对应的行, 否则锁住整个表, 使用时一定注意.</p><pre><code class="mysql"># 1. 事务1 执行select * from test where name = &#39;zhao&#39; for update;# 2. 事务2 执行select * from test where name = &#39;xi&#39; for update;## 可以观察事务2 会一直阻塞# 3. 事务1 执行 rollback## 观察事务2 在事务1 执行完毕后, 事务2也执行成功# 4. 为age字段添加索引create index idx_test_age on test(age);commit;# 5. 事务1 执行select * from test where age = 22 for update;# 6. 事务2 执行select * from test where age = 21 for update;commit;## 可以观察事务2 并不会阻塞# 7. 事务1 执行 rollbackrollback;# 8. 设置数据库自动提交set autocommit = 1;</code></pre><h2 id="悲观锁的弱化版本"><a href="#悲观锁的弱化版本" class="headerlink" title="悲观锁的弱化版本"></a>悲观锁的弱化版本</h2><p>悲观锁也可以使用 select … lock in share mode 来实现, 不过相对select … for update 来说, 前者不会阻塞查询. 因为 前者使用 IS (意向共享锁) 锁, 后则使用 IX (意向排他锁) 锁.<br>下面验证下 select … lock in share mode.</p><pre><code class="mysql"># 1. 设置数据库不自动提交set autocommit = 0;# 2. 事务1 执行select * from test where id = 1 lock in share mode; # 3. 事务2 执行select * from test where id = 1 lock in share mode;  commit;## 可以观察事务2 并没有阻塞# 4. 事务2 执行update test set age = 23 where id = 1;commit;## 可以观察事务2 会阻塞在update语句# 5. 事务1 执行rollback;rollback;## 可以观察事务2 事务正常提交# 6. 设置数据库自动提交set autocommit = 1;</code></pre><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁大部分实现基于版本机制(Version 或者 Timestamp)来实现, 相对悲观锁更加宽松, 大多数情况下, 并发比悲观锁高, 所以开发实际运用更趋近于乐观锁.</p><h4 id="实现乐观锁"><a href="#实现乐观锁" class="headerlink" title="实现乐观锁"></a>实现乐观锁</h4><pre><code class="mysql"># 1. 更新数据库, 新增version 字段ALTER table test add version int not null;# 2. 设置数据库不自动提交set autocommit = 0;# 3. 事务1 执行select * from test where id = 1 ; ## 可以观察事务2 version 字段为 0# 4. 事务2 执行select * from test where id = 1;## 可以观察事务2 version 字段为 0# 5. 事务1 执行update test set age = 24 , version = version+1 where id = 1 and version = 0;commit;## 可以观察事务1 事务正常提交# 6. 事务2 执行update test set age = 24 , version = version+1 where id = 1 and version = 0;commit;## 可以观察事务2 正常提交, 但是受影响的行数为 0.# 7. 设置数据库自动提交set autocommit = 1;commit;</code></pre><h4 id="乐观锁使用建议"><a href="#乐观锁使用建议" class="headerlink" title="乐观锁使用建议"></a>乐观锁使用建议</h4><p>乐观锁在使用的时候, 不一定在同一事务中, 只是检测version字段更新时是否和读取时值保持一致, 若一致则更新, 否则更新失败. 现在很多orm 都有实现version自动更新的功能, 使用非常方便, 也推荐使用该方式处理并发.</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis为什么这么快之服务器事件驱动</title>
      <link href="/2019/01/01/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
      <url>/2019/01/01/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis 是使用 C语言编写的 key-value 数据库, 操作速度极快, 整体来说, 可以从数据结构和服务器事件驱动两个方面类来解释. 下面就介绍redis的服务器事件驱动.</p><h2 id="Redis-服务器事件驱动类型"><a href="#Redis-服务器事件驱动类型" class="headerlink" title="Redis 服务器事件驱动类型"></a>Redis 服务器事件驱动类型</h2><ul><li>文件事件 (file event) Redis 通过套接字连接客户端, 文件事件就是服务器对套接字的抽象. </li><li>时间事件 (time event) 服务器中的一些操作需要定时执行, 时间事件就是服务器对这类型操作的抽象. </li></ul><h2 id="文件事件-file-event"><a href="#文件事件-file-event" class="headerlink" title="文件事件(file event)"></a>文件事件(file event)</h2><p>Redis 使用了 Reactor 模式来开发自己的网络事件处理器, 这里叫文件事件处理器, 其特点是</p><ol><li>使用 IO多路复用(multiplexing) 程序来同时监听多个套接字, 并根据套接字目前的执行任务来为套接字关联不同的事件处理器.</li><li>当被监听的套接字准备好执行 连接(accept), 读取(read), 写入(write), 关闭(close)时, 就会产生对应的文件事件, 网络事件处理器就是调用关联的事件处理器处理事件.</li><li>事件处理器是单线程方式运行, 通过使用IO多路复用程序来监听多个套接字, 这样即实现了高效网络通信, 又方便与Redis中其他单线层模块对接, 也保持了设计的简单性.</li></ol><h2 id="文件事件构成"><a href="#文件事件构成" class="headerlink" title="文件事件构成"></a>文件事件构成</h2><p><img src="/.io//1.png" alt="在这里插入图片描述"></p><ol><li>套接字Socket</li><li>IO多路复用程序 (Reactor 模式)<br> 主要将1的套接字放入一个队列, 然后有序同步的将套接字传输给文件事件分派器, 当上一个套接字处理完毕后, 再继续传输下一个套接字.<br> 主要实现是 利用select, poll, epoll 同时监察多个IO流, 空闲时阻塞, 有IO流时, 轮训一遍所有流并按照顺序依次处理, 避免了大量无用操作. 提高了整体IO效率.</li><li>文件事件分派器dispatcher</li><li>事件处理器</li></ol><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><ul><li>定时事件: 指定时间之后执行一次.</li><li>周期事件: 间隔时间执行一次.<br>周期事件是一个无序的链表, 每个节点由一个编号, 一个时间戳, 一个处理事件构成. 遍历一次曾可以保证所有到达时间的事件全部处理.</li></ul><h2 id="总结-为什么这么快"><a href="#总结-为什么这么快" class="headerlink" title="总结 为什么这么快"></a>总结 为什么这么快</h2><ol><li>Redis 是使用内存操作</li><li>Redis 的IO 因为使用了多路复用模型, 非阻塞IO. 所以在IO上非常高效;</li><li>Redis 基于内存操作, 所以CPU不是Redis的瓶颈, 所以省去了多线程的加锁, 竞争, 切换等的性能消耗.</li><li>Redis 中所有的数据结构都是根据KeyValue的具体类型而定, 非常高效.</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Redis 设计与实现</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis为什么这么快之数据结构</title>
      <link href="/2018/12/31/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2018/12/31/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis 是使用 C语言编写的 key-value 数据库, 操作速度极快, 整体来说, 可以从数据结构和服务器事件驱动两个方面来解释. 下面就介绍redis所以引用的数据结构.</p><h2 id="String-类型的数据结构SDS"><a href="#String-类型的数据结构SDS" class="headerlink" title="String 类型的数据结构SDS"></a>String 类型的数据结构SDS</h2><p>Redis 没有使用 C语言传统的字符串, 而是构建了自定义的 SDS(simple dynamic string) 类型. Redis 使用C类型字符串的地方只是在一些字符串无需修改的地方, 如日志打印.<br>包含字符串的键值对在底层都是使用 SDS 实现的.</p><ol><li>SDS 的定义<pre><code class="c">struct sdshdr{ int len; // 记录buf数组已使用的字节的长度, 也是sds 字符串的长度. int free; // 记录buf数组中未使用字节的数量 char buf[]; // 字节数组, 用于保存字符串}// SDS 实例 free = 0 // 表示该sds 没有分配任何使用空间len = 5 // 表示该sds 保存了一个5个字节长度的字符串buf = [&#39;R&#39;,&#39;e&#39;,&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;\0&#39;] // char数组, 前五个字符为 &#39;R&#39;,&#39;e&#39;,&#39;d&#39;,&#39;i&#39;,&#39;s&#39;;0// 最后一个字节则保存了空字符串 &#39;\0&#39;. 这样的好处是可以重用部分 C 函数.</code></pre></li><li>SDS 的字符串连接策略</li></ol><ul><li>当修改后len 长度小于1MB时, free 分配len 长度相同的空间<br>```c<br>free = 0                                      free = 10<br>len = 5                         + “Redis”  =&gt; len = 10<br>buf = [‘R’,’e’,’d’,’i’,’s’,’\0’]len=6         buf = [‘R’,’e’,’d’,’i’,’s’,’R’,’e’,’d’,’i’,’s’,’\0’,…]len=21(free + len + 1)</li><li>当修改后len 长度大于1MB时, free 固定分配 1MB 的空间<pre><code class="c">free = 0                            free = 1MBlen = 0.9MB    + &quot;长度1MB字符串&quot; =&gt;  len = 1.9MBbuf = [...]len=2MB                  buf = [...]len=2.9MB + 1byte(free + len + 1byte)</code></pre></li></ul><pre><code>3. SDS 的字符串移除策略, 修改free, len, buf 的值, 但是不回收空间, 避免再操作时重新分配内存的问题.4. SDS 字符串二进制安全, 是因为它写入时, 直接将元数据写入到buf, 而不做任何限制过滤. 读取时, 是根据len来读取, 而不是和C语言类似的以 &#39;\0&#39;结尾, 遇到特殊字符就被截断的问题. 写入什么就读取什么.相对C字符串的优点- 常熟复杂度的获取字符串长度- 杜绝缓冲区移除- 减少修改字符串长度时所需的内存分配次数- 二进制安全- 兼容部分 C 字符串函数## 链表 LinkedList List 使用LinkedList(链表)作为数据结构, 出了List之外, 发布订阅, 慢查询, 监视器 也用到了链表.1. ListNode 定义```ctypeof struct listNode{    struct listNode *prev; // 前置节点    struct listNode *next; // 后置节点    void *value; // 节点的值}</code></pre><ol start="2"><li>LinkedList 的定义<pre><code class="c">typeof struct list{ listNode *head; // 表头 (首节点指向null, 不形成环形) listNode *tail; // 表尾 (尾节点指向null, 不形成环形) unsigned long len; // 链表长度 void *(*dup)(void *ptr); // 复制节点所保存的值 void (*free)(void *ptr); // 释放节点所保存的值 int (*match)(void *ptr, void *key); // 用于对比节点所保存的值和另一个输入值是否相等.}</code></pre></li><li>链表作为一个常见数据结构, 使用场景很多, 不用过多的介绍.</li></ol><h2 id="字典-Dic"><a href="#字典-Dic" class="headerlink" title="字典 Dic"></a>字典 Dic</h2><p>字典是Redis 的String操作的底层实现</p><ol><li>字典的底层实现则是 哈希表<pre><code class="c">typeof struct dict{ dictType *type; // 类型特定函数 void *privatedata; // 私有数据, 保存哪些传递给特定函数的可选参数 dictht ht[2]; // 哈希表, 字典只使用ht[0], 当进行rehash时使用 ht[1]. int treshahidx; // rehash 索引, 当rehash 不再行进中时, 值为-1}</code></pre></li></ol><p>typeof struct dictht{<br>    dictEntry **table;// 哈希表数组<br>    unsigned long size; // 哈希表大小<br>    unsigned long sizemask; // 哈希表大小掩码, 用于计算索引值. 总等于1<br>    unsigned long used; // 该哈希表当前节点数量<br>}</p><p>typeof struct dictEntry{<br>    void *key; // 键<br>    union{ // 值<br>        void *val;<br>        uint64 _tu64;<br>        int64 _ts64;<br>    } v;<br>    struct dictEntry *next; // 指向下一个哈希表节点, 形成环形<br>};</p><pre><code>2. 计算hash的方法是 MurmurHash2 算法.3. rehash时启用ht[1], 但是不是一次性完成, 而是渐进式完成.4. 整体执行过程和 java中hashmap 类似. 这里不做过多的讲解.## 跳跃表 skiplistZSET 在包含元素数量较多时就是使用 skiplist实现, 另一个地方就是集群节点的内部结构. 其效率可以和平衡树媲美, 且实现更简单.插入和删除的时间复杂度就是查询元素插入位置的时间复杂度, 即 O(logN).1. 结构定义```ctypeof struct zskiplist{    struct skiplistNode *head, *tail; // 表头节点和表尾节点    unsigned long length; // 表中节点的数量    int level; // 表中层数最大的节点的层数}typeof struct zskiplistNode{    struct zskiplistLevel{ // 层        struct zskiplistNode *forward; // 前进指针        unsigned int span; // 跨度    } level[];    struct zskiplistNode *backward; // 后退指针     double score; // 分数    robj *obj; // 成员对象}</code></pre><ol start="2"><li>跳跃表的一些特点</li></ol><ul><li>Redis跳跃表的节点本身是一个链表节点</li><li>跳跃表的每个节点包含一个数组类型的层字段, 层中的元素包含指向后序第n个节点的指针</li></ul><ol start="3"><li>跳跃表的插入操作<pre><code class="c">// 插入第一个数 1 Level1:  head -&gt; Node(1)// 插入第二个数 2. 1: 先插入节点到Level1, 然后根据随机算法生成level数, 假如level=2 Level2: head -&gt; Node(1) -&gt; Node(2)Level1: head -&gt; Node(1) -&gt; Node(2)// 插入第三个数 3. 1: 和插入第二个节点类似, 假如level=1Level2: head -&gt; Node(1) -&gt; Node(2)Level1: head -&gt; Node(1) -&gt; Node(2) -&gt; Node(3)// 插入第四个数 4. 1: 和插入第二个节点类似, 假如level=1Level3: head -&gt; Node(1)            -&gt;            Node(4)Level2: head -&gt; Node(1) -&gt; Node(2)Level1: head -&gt; Node(1) -&gt; Node(2) -&gt; Node(3) -&gt; Node(4)</code></pre></li><li>跳跃表的随机算法<br>level = n 的概率就是 ZSKIPLIST_P ^ (n-1)<pre><code class="c">int zslRandomLevel(void) { int level = 1; while ((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF)) // ZSKIPLIST_P = 0.25     level += 1; return (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL; // ZSKIPLIST_MAXLEVEL = 32}</code></pre></li><li>跳跃表的查找<ol><li>从最高层通过forward指针向前查找, 如果前一个元素大于待查找元素或者遇到tail指针, level -1 继续查找; 如果前一个元素小于带查找元素, 那么继续通过forward 向前查找.</li><li>重复步骤1, 直到找到节点或者返回null.</li></ol></li></ol><h2 id="整数集合-intset"><a href="#整数集合-intset" class="headerlink" title="整数集合 intset"></a>整数集合 intset</h2><p>intset 是Set 的底层实现之一, 当一个集合只包含整数值元素且元素不多的时候启用.</p><ol><li><p>结构定义</p><pre><code class="c">typeof struct intset{ // 编码方式: 1. INTSET_ENC_INT16 content中是int16_t的整数值 // 2. INTSET_ENC_INT32 content中是int32_t的整数值 // 2. INTSET_ENC_INT64 content中是int64_t的整数值 uint32_t encoding;  uint32_t length;// 集合中的元素数量 int8_t contents[]; // 元素数组} intset;</code></pre></li><li><p>升级和降级<br>当数组中存放的三个元素1,2,3时, encoding是 int16_t, 当插入65536之后, encoding就将变成 int32_t, 然后数组长度从 16<em>3 变成 32</em>4, 这个过程称之为<strong>升级</strong>.<br>当数组中存放的四个元素1,2,3, 65536时, encoding是 int32_t, 当删除65536之后, encoding不改变, 然后数组长度从 32<em>4 变成 32</em>3, 这个过程称之为<strong>降级</strong>.</p></li><li><p>升级操作为整数集合带来了操作上的灵活性, 并且节约了内存; 整数集合只支持升级不支持降级.</p></li></ol><h2 id="压缩列表-ziplist"><a href="#压缩列表-ziplist" class="headerlink" title="压缩列表 ziplist"></a>压缩列表 ziplist</h2><p>压缩列表是 list和hash 的底层实现之一. 当list 中只包含少量项并且 每个列表项都是小整数或较短的字符串, 就会使用压缩表. 主要是为了节约内存而开发的顺序型结构.</p><h2 id="对象-object"><a href="#对象-object" class="headerlink" title="对象 object"></a>对象 object</h2><ol><li>当我们操作redis 时, 不是直接操作上面的数据结构, 而是操作对象结构, 并给对象设置所使用编码. 编码对应其真正使用的底层结构. 这样能提升 Redis 的灵活性和效率.</li></ol><ul><li>REIDS_STRING 字符串 编码类型:  int , raw(SDS), embstr.</li><li>REDIS_LIST 列表 编码类型: ziplist, linkedlist.</li><li>REDIS_HASH 哈希表 编码类型: ziplist, hashtable</li><li>REDIS_SET 集合 编码类型: intset, hashtable</li><li>REDIS_ZSET 有序集合 编码类型: ziplist, skiplist </li></ul><ol start="2"><li>对象共享机制<br>假如键A 创建了一个整型值 100, 在键B 创建另外一个 整型值100 的时候, 直接将键A 的值指向 键B, 更新了整型值的引用计数而已. 这样有效的节约了内存.<br>共享机制只共享整数值(0-9999)的字符串, 不共享其他类型.</li><li>对象的引用计数为0 时, 自动释放内存.</li><li>对象会记录自己最后一次被访问时间, 这样当服务器的回收策略合适时, 会回收这些内存, 提高效率.</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis 数据结构高效的真正原因就是因为数据结构 <strong>对象</strong>的原因. </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Redis 设计与实现</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的数据持久化方式</title>
      <link href="/2018/12/30/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/12/30/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-的持久化简介"><a href="#Redis-的持久化简介" class="headerlink" title="Redis 的持久化简介"></a>Redis 的持久化简介</h2><p>Redis提供了两种不同的方式将数据持久化到硬盘中, 使得数据在Redis 重启后仍然存在. 将内存中的数据存储到硬盘的一个主要问题就是为了在之后重用数据, 或者是为了防止系统故障而将数据备份到一个远程位置. </p><h2 id="Redis-持久化的两种方式"><a href="#Redis-持久化的两种方式" class="headerlink" title="Redis 持久化的两种方式"></a>Redis 持久化的两种方式</h2><h4 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h4><p>RDB 持久化又称为快照(snapchotting), 它可以将某一时刻的所有数据全部写入到硬盘中, 存储到后缀为.rdb文件中.</p><p>RDB 持久化的触发方式</p><ul><li>[手动] 客户端发送 <strong>BGSAVE</strong> 命令来创建一个快照. Redis会调用fork 来创建一个子进程, 子进程负责写入快照到硬盘, 父进程继续处理命令请求.</li><li>[手动] 客户端发送 <strong>SAVE</strong> 命令来创建一个快照. Redis 会在快照创建完毕之前不处理任何命令. 一般在没有足够内存去执行 BGSAVE 的情况下, 或者等待持久化无所谓的情况 才会使用 SAVE 命令.</li><li>[自动] 服务端配置设置 save 选项. save 60 10000 命令含义是 “60秒内有10 000次写入” 这个条件满足时, 自动调用 BGSAVE 命令. 如果有多个save配置, 任意一个满足则触发 BGSAVE命令.</li><li>[自动] 服务端接受 SHUTDOWN 命令关闭服务器时, 或者接受到标准 TERM 信号时,  自动执行 SAVE 命令. 并在结束时关闭服务器.</li><li>[自动] 当一个 Redis 服务器连接另一个 Redis 服务器, 并向对方发送 SYNC 命令开始一次复制操作的时候, 如果主服务器并非刚刚执行 BGSAVE 命令, 那么主服务器就会执行 BGSAVE 命令.</li></ul><h4 id="RDB-可能的问题和解决办法"><a href="#RDB-可能的问题和解决办法" class="headerlink" title="RDB 可能的问题和解决办法"></a>RDB 可能的问题和解决办法</h4><p>问题1: 当 Redis 存储的数据量只有几GB的时候, 快照是完全没有问题的. 当内存占用高达几十个GB, 并且剩余内存不多的时候, BGSAVE 创建子进程可能导致系统长时间卡顿, 也可能引发系统大量地使用虚拟内存,从而导致 Redis 的性能降低至无法使用的程度.<br>解决办法：使用 SAVE 命令来代替 BGSAVE 命令,因为没有了子进程争抢资源, 所以会比 BGSAVE 快一些.</p><p>问题2: 在执行 BGSAVE 或者 SAVE 命令的间隙, Redis 发生异常, 会造成间隙的数据会丢失.<br>解决办法：如果使用RDB方式无法解决, 只能使用 AOF 方式. </p><h4 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h4><p>AOF(append-only file) 持久化, 它会在执行写命令时, 将被执行的写命令写入到后缀为.aof文件里面.</p><p>AOF 触发方式(默认为 no)<br>appendonly yes</p><p>AOF 的同步频率  appendfsync</p><ul><li>always: 每个 Redis 命令都要同步写入到硬盘, 这样会严重降低 Redis 的速度. 固态硬盘用户需要谨慎使用该选项, 可能引发ssd的写入放大问题, 将低ssd的使用寿命.</li><li>everysec (default): 每秒执行一次同步, 显示地将多个命令同步到硬盘. </li><li>no: 让操作系统决定应该何时进行同步. </li></ul><h4 id="AOF可能的问题及解决方式"><a href="#AOF可能的问题及解决方式" class="headerlink" title="AOF可能的问题及解决方式"></a>AOF可能的问题及解决方式</h4><p>问题1: AOF如果使用 everysec 的同步频率, 可以将丢失数据的窗口降低到1秒, 为什么Redis默认不启用AOF?<br>回答: 1. 因为 Redis 不断写入记录到 AOF 文件中, 随着 Redis 的运行, AOF 的体积也不短增大, 极端情况, 可能占用所有硬盘; 2. 当 AOF 过大的时候, 重启 Redis 重新执行 AOF 文件来还原数据集时, 执行时间可能非常长. </p><p>问题2: 如何解决 AOF 文件体积不断增大的问题?<br>解决办法: 执行 BGREWRITEAOF 命令, 压缩 AOF 文件, 使得其体积尽可能小. 该命令的工作原理: Redis 创建一个子进程, 使用子进程重写 AOF 文件.</p><p>问题3: 是否可以自动执行 BGREWRITEAOF 命令?<br>回答: 可以自动执行, 需要开启配置 auto-aof-rewrite-percentage 和 auto-aof-rewrite-min-size 两个选项, 设置 启动 AOF持久化且 auto-aof-rewrite-percentage 100, auto-aof-rewrite-min-size 64MB 时, 当 AOF 文件大于64MB, 且 AOF 文件的体积比上一次重写之后的体积大了一倍, Redis 将执行 BGREWRITEAOF 命令.</p><h2 id="持久化的比较"><a href="#持久化的比较" class="headerlink" title="持久化的比较"></a>持久化的比较</h2><p>下面的比较都是在数据量较大, 且配置设置合理的情况下 相对而言的比较.</p><table><thead><tr><th align="left">持久化方式</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">RDB</td><td align="left">1. 文件紧凑, 体积小<br> 2. 恢复速度快<br></td><td align="left">1. 不能实时持久化, 备份间隙数据丢失严重<br> 2. 不同版本可能有兼容性问题</td></tr><tr><td align="left">AOF</td><td align="left">1. 备份速度快 <br> 2. 不同版本兼容性好</td><td align="left">1. 文件大<br> 2. 恢复速度慢</td></tr></tbody></table><h2 id="持久化的选择"><a href="#持久化的选择" class="headerlink" title="持久化的选择"></a>持久化的选择</h2><ol><li>只用来数据缓存, 则可以都不启用.</li><li>单机情况下, 如果数据完整性要求较高 建议开启 AOF持久 或者 AOF RDB 双持久, 如果对数据完整性要求不高, 可以只开启 RDB. 具体的参数设置根据实际业务调整.</li><li>主从情况下, master 两种方式都关闭, slaver 开启 aof 并定时执行 BGREWRITEAOF 命令.</li></ol><h2 id="引用文献"><a href="#引用文献" class="headerlink" title="引用文献"></a>引用文献</h2><p>Redis in Action (Redis 实战)</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的数据类型和基本使用</title>
      <link href="/2018/12/29/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/12/29/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis简介及特点"><a href="#Redis简介及特点" class="headerlink" title="Redis简介及特点"></a>Redis简介及特点</h2><p>Redis是一个开源高效率的Key-Value内存数据库.</p><ul><li>支持多种数据结构 string, list, set, zset, hash, 并支持push, pop, 交并差集等多种操作, 并支持数据的持久化.</li><li>全内存操作, 性能极高, 官方数据: read高达 110000次/s, write高达 81000次/s.</li><li>操作原子性, 单操作原子性, 多操作使用MULTI和EXEC指令包裹执行保证原子性. </li><li>支持数据持久化.</li><li>支持数据publish/subscribe.</li><li>支持master-slaver(主从)同步, 集群操作.</li></ul><h2 id="Redis常用数据结构及使用"><a href="#Redis常用数据结构及使用" class="headerlink" title="Redis常用数据结构及使用"></a>Redis常用数据结构及使用</h2><h4 id="启动redis-server-win"><a href="#启动redis-server-win" class="headerlink" title="启动redis-server (win)"></a>启动redis-server (win)</h4><p>假设redis的目录是 e:\soft\redis</p><ol><li>命令行移动到redis运行目录: cd e:\soft\redis</li><li>启动服务端:  redis-server.exe redis.conf  (服务端exe 配置文件可选)</li></ol><h4 id="使用redis-cli操作redis"><a href="#使用redis-cli操作redis" class="headerlink" title="使用redis-cli操作redis"></a>使用redis-cli操作redis</h4><p>在redis运行目录执行: redis-cli -h 127.0.0.1 -p 6379  (-h, -p 默认参数就是127.0.0.1, 6379 可不写)</p><h4 id="String-字符串常用操作"><a href="#String-字符串常用操作" class="headerlink" title="String 字符串常用操作"></a>String 字符串常用操作</h4><ul><li>String 是最基础的Redis数据类型, 它是二进制安全的, 意味着String可以存储任何类型的数据, 例如jpeg图像和序列化对象. </li><li>单个String 的最大长度是512MB</li><li>绝大部分操作的复杂度是O(1), 返回多个元素除外.</li><li>使用场景探索: 常用来做数据缓存</li></ul><table><thead><tr><th align="left">String 命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">SET key value</td><td align="left">设置指定key value 的值</td></tr><tr><td align="left">GET key</td><td align="left">获取指定key 的值</td></tr><tr><td align="left">GETRANGE key start end</td><td align="left">返回指定key 的子串</td></tr><tr><td align="left">GETSET key value</td><td align="left">将给定key 的值设为value, 并返回key 的旧值(old value)</td></tr><tr><td align="left">GETBIT key offset</td><td align="left">对key 所储存的字符串值, 获取指定偏移量上的位(bit)</td></tr><tr><td align="left">MGET key1 key2 key3..</td><td align="left">根据给定的key 数组, 返回value 数组</td></tr><tr><td align="left">SETBIT key offset value</td><td align="left">对key 所储存的字符串值, 设置或清除指定偏移量上的位(bit)</td></tr><tr><td align="left">SETEX key seconds value</td><td align="left">将值 value 关联到key, 并将key 的过期时间设为 seconds (以秒为单位)</td></tr><tr><td align="left">SETNX key value</td><td align="left">只有在 key 不存在时设置key 的值</td></tr><tr><td align="left">SETRANGE key offset value</td><td align="left">用value 参数覆写给定key 所储存的字符串值, 从偏移量offset 开始</td></tr><tr><td align="left">STRLEN key</td><td align="left">返回key 所储存的字符串值的长度</td></tr><tr><td align="left">MSET key value [key value] […]</td><td align="left">同时设置一个或多个key-value 键值对</td></tr><tr><td align="left">MSETNX key value [key value] […]</td><td align="left">同时设置一个或多个key-value 对, 当且仅当所有给定key 都不存在</td></tr><tr><td align="left">PSETEX key milliseconds value</td><td align="left">将值value 关联到key , 并将key 的过期时间设为milliseconds (以毫秒为单位)</td></tr><tr><td align="left">INCR key</td><td align="left">将key 中存储的数字加1</td></tr><tr><td align="left">INCRBY key increment</td><td align="left">将key 所储存的值加上给定的增量值</td></tr><tr><td align="left">INCRBYFLOAT key increment</td><td align="left">将key 所储存的值加上给定的浮点增量值</td></tr><tr><td align="left">DECR key</td><td align="left">将key 中储存的数字值减1</td></tr><tr><td align="left">DECRBY key decrement</td><td align="left">对key 所储存的值减去给定的减量值</td></tr><tr><td align="left">APPEND key value</td><td align="left">如果key 已经存在并且是一个字符串,  APPEND 命令将指定的value 追加到该key 原来值（value）的末尾</td></tr></tbody></table><pre><code class="java">// 首先需要引入 Jedis 库, 启动redis 服务端public static void main(String[] args) {    Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); // 服务器ip和端口    System.out.print(jedis.set(&quot;name&quot;, &quot;zhaoxi&quot;)); // OK     System.out.println(&quot; &quot; + jedis.get(&quot;name&quot;)); // zhaoxi    System.out.print(jedis.append(&quot;name&quot;, &quot;append&quot;)); // 12    System.out.print(&quot; &quot; + jedis.get(&quot;name&quot;));  // zhaoxiappend}</code></pre><h4 id="Hash-哈希常用操作"><a href="#Hash-哈希常用操作" class="headerlink" title="Hash 哈希常用操作"></a>Hash 哈希常用操作</h4><ul><li>Hash 是字符串的键值对, 所以方便存储对象</li><li>每个hash key最多存储 2^32 - 1 个键值对.</li><li>新增和删除都是O(1), 其他视命令而定</li><li>使用场景探索: 对象的直接缓存, 不通过String存储</li></ul><table><thead><tr><th align="left">Hash 命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">HDEL key field1 [field2]</td><td align="left">删除一个或多个哈希表字段</td></tr><tr><td align="left">HEXISTS key field</td><td align="left">查看哈希表 key 中, 指定的字段是否存在</td></tr><tr><td align="left">HGET key field</td><td align="left">获取存储在哈希表中指定字段的值</td></tr><tr><td align="left">HGETALL key</td><td align="left">获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td align="left">HINCRBY key field increment</td><td align="left">为哈希表 key 中的指定字段的整数值加上增量 increment</td></tr><tr><td align="left">HINCRBYFLOAT key field increment</td><td align="left">为哈希表 key 中的指定字段的浮点数值加上增量 increment</td></tr><tr><td align="left">HKEYS key</td><td align="left">获取所有哈希表中的字段</td></tr><tr><td align="left">HLEN key</td><td align="left">获取哈希表中字段的数量</td></tr><tr><td align="left">HMGET key field1 [field2]</td><td align="left">获取所有给定字段的值</td></tr><tr><td align="left">HMSET key field1 value1 [field2 value2 ]</td><td align="left">同时将多个 field-value (域-值)对设置到哈希表 key 中</td></tr><tr><td align="left">HSET key field value</td><td align="left">将哈希表 key 中的字段 field 的值设为 value</td></tr><tr><td align="left">HSETNX key field value</td><td align="left">只有在字段 field 不存在时, 设置哈希表字段的值</td></tr><tr><td align="left">HVALS key</td><td align="left">获取哈希表中所有值</td></tr><tr><td align="left">HSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">迭代哈希表中的键值对</td></tr></tbody></table><pre><code class="java">// 首先需要引入 Jedis 库, 启动redis 服务端public static void main(String[] args) {    Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); // 服务器ip和端口    System.out.print(jedis.hset(&quot;user&quot;, &quot;name&quot;, &quot;zhaoxi&quot;)); // 1    System.out.println(&quot; &quot; + jedis.hset(&quot;user&quot;, &quot;desc&quot;, &quot;pr&quot;)); // 1    System.out.print(jedis.hget(&quot;user&quot;, &quot;name&quot;)); // zhaoxi    System.out.println(&quot; &quot; + jedis.hget(&quot;user&quot;, &quot;desc&quot;)); // pr} </code></pre><h4 id="List-列表常用操作"><a href="#List-列表常用操作" class="headerlink" title="List 列表常用操作"></a>List 列表常用操作</h4><ul><li>List 是字符串的列表(Linked List), 按照插入顺序排序. 每个字符串首尾指向前后一个字符串.</li><li>单个 List 的最大长度是 2^32 - 1</li><li>Redis 从首尾插入删除元素复杂度恒定为O(1), 从首尾访问元素复杂度也是O(1), 但是访问很大的列表时, 速度很慢, 复杂度为O(n) </li><li>使用场景探索: 配合lpush 和ltrim , 监测一个用户最近访问的最新n 个值</li></ul><table><thead><tr><th align="left">List 命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">BLPOP key1 [key2 ] timeout</td><td align="left">移出并获取列表的第一个元素, 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td align="left">BRPOP key1 [key2 ] timeout</td><td align="left">移出并获取列表的最后一个元素, 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td align="left">BRPOPLPUSH source destination timeout</td><td align="left">从列表中弹出一个值,将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td align="left">LINDEX key index</td><td align="left">通过索引获取列表中的元素</td></tr><tr><td align="left">LINSERT key BEFORE</td><td align="left">AFTER pivot value</td></tr><tr><td align="left">LLEN key</td><td align="left">获取列表长度</td></tr><tr><td align="left">LPOP key</td><td align="left">移出并获取列表的第一个元素</td></tr><tr><td align="left">LPUSH key value1 [value2]</td><td align="left">将一个或多个值插入到列表头部</td></tr><tr><td align="left">LPUSHX key value</td><td align="left">将一个值插入到已存在的列表头部</td></tr><tr><td align="left">LRANGE key start stop</td><td align="left">获取列表指定范围内的元素</td></tr><tr><td align="left">LREM key count value</td><td align="left">移除列表元素</td></tr><tr><td align="left">LSET key index value</td><td align="left">通过索引设置列表元素的值</td></tr><tr><td align="left">LTRIM key start stop</td><td align="left">对一个列表进行修剪(trim),就是说,让列表只保留指定区间内的元素,不在指定区间之内的元素都将被删除</td></tr><tr><td align="left">RPOP key</td><td align="left">移除列表的最后一个元素,返回值为移除的元素</td></tr><tr><td align="left">RPOPLPUSH source destination</td><td align="left">移除列表的最后一个元素,并将该元素添加到另一个列表并返回</td></tr><tr><td align="left">RPUSH key value1 [value2]</td><td align="left">在列表中添加一个或多个值</td></tr><tr><td align="left">RPUSHX key value</td><td align="left">为已存在的列表添加值</td></tr></tbody></table><pre><code class="java">// 首先需要引入 Jedis 库, 启动redis 服务端public static void main(String[] args) {    Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);    System.out.println(jedis.lpush(&quot;list&quot;, &quot;index1&quot;)); // 1    System.out.println(jedis.lpush(&quot;list&quot;, &quot;index2&quot;)); // 2    System.out.println(jedis.lpush(&quot;list&quot;, &quot;index3&quot;)); // 3    System.out.println(jedis.lrem(&quot;list&quot;, 1, &quot;index1&quot;)); // 1    System.out.println(jedis.lrange(&quot;list&quot;, 0, -1)); // [index3, index2]    System.out.println(jedis.lpop(&quot;list&quot;)); // index3    System.out.println(jedis.lpop(&quot;list&quot;));  // index2    System.out.println(jedis.lrange(&quot;list&quot;, 0, -1)); // []}</code></pre><h4 id="Set-集合常用操作"><a href="#Set-集合常用操作" class="headerlink" title="Set 集合常用操作"></a>Set 集合常用操作</h4><ul><li>Set 是不允许重复切无序的列表</li><li>单个 Set 的最大成员数 2^32 - 1个</li><li>向 Set 中添加, 删除, 检测元素存在时间复杂度都是O(1)</li><li>使用场景探索: 监测一个帖子的访问ip 地址, 每次访问的时候直接将ip 插入到set, 不用担心唯一的问题.</li></ul><table><thead><tr><th align="left">Set 命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">SADD key member1 [member2]</td><td align="left">向集合添加一个或多个成员</td></tr><tr><td align="left">SCARD key</td><td align="left">获取集合的成员数</td></tr><tr><td align="left">SDIFF key1 [key2]</td><td align="left">返回给定所有集合的差集</td></tr><tr><td align="left">SDIFFSTORE destination key1 [key2]</td><td align="left">返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td align="left">SINTER key1 [key2]</td><td align="left">返回给定所有集合的交集</td></tr><tr><td align="left">SINTERSTORE destination key1 [key2]</td><td align="left">返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td align="left">SISMEMBER key member</td><td align="left">判断 member 元素是否是集合 key 的成员</td></tr><tr><td align="left">SMEMBERS key</td><td align="left">返回集合中的所有成员</td></tr><tr><td align="left">SMOVE source destination member</td><td align="left">将 member 元素从 source 集合移动到 destination 集合</td></tr><tr><td align="left">SPOP key</td><td align="left">移除并返回集合中的一个随机元素</td></tr><tr><td align="left">SRANDMEMBER key [count]</td><td align="left">返回集合中一个或多个随机数</td></tr><tr><td align="left">SREM key member1 [member2]</td><td align="left">移除集合中一个或多个成员</td></tr><tr><td align="left">SUNION key1 [key2]</td><td align="left">返回所有给定集合的并集</td></tr><tr><td align="left">SUNIONSTORE destination key1 [key2]</td><td align="left">所有给定集合的并集存储在 destination 集合中</td></tr><tr><td align="left">SSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">迭代集合中的元素</td></tr></tbody></table><pre><code class="java">// 首先需要引入 Jedis 库, 启动redis 服务端public static void main(String[] args) {    Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);    System.out.println(jedis.sadd(&quot;set#name#1&quot;, &quot;zhaoxi&quot;, &quot;wuyu&quot;, &quot;mailang&quot;)); // 3    System.out.println(jedis.sadd(&quot;set#name#1&quot;, &quot;zhaoxi&quot;)); // 0  说明已存在    System.out.println(jedis.sadd(&quot;set#name#2&quot;, &quot;zhaoxi&quot;,&quot;yiyi&quot;)); // 2    System.out.println(jedis.sdiff(&quot;set#name#2&quot;, &quot;set#name#1&quot;)); // [yiyi]    System.out.println(jedis.sinter(&quot;set#name#2&quot;, &quot;set#name#1&quot;)); // [zhaoxi]    System.out.println(jedis.sunion(&quot;set#name#2&quot;, &quot;set#name#1&quot;)); // [wuyu, mailang, zhaoxi, yiyi]     System.out.println(jedis.del(&quot;set#name#2&quot;, &quot;set#name#1&quot;)); // 2}</code></pre><h4 id="ZSet-有序集合常用操作"><a href="#ZSet-有序集合常用操作" class="headerlink" title="ZSet 有序集合常用操作"></a>ZSet 有序集合常用操作</h4><ul><li>ZSet 类似 Set 和 Hash 的混合体. </li><li>每个有序元素都和一个浮点数(分数)相关联.</li><li>添加,删除,查找的复杂度都是O(1)</li><li>使用场景探索: 游戏中的排名, 榜单.</li></ul><table><thead><tr><th align="left">ZSet 命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ZADD key score1 member1 [score2 member2]</td><td align="left">向有序集合添加一个或多个成员,或者更新已存在成员的分数</td></tr><tr><td align="left">ZCARD key</td><td align="left">获取有序集合的成员数</td></tr><tr><td align="left">ZCOUNT key min max</td><td align="left">计算在有序集合中指定区间分数的成员数</td></tr><tr><td align="left">ZINCRBY key increment member</td><td align="left">有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td align="left">ZINTERSTORE destination numkeys key [key …]</td><td align="left">计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td></tr><tr><td align="left">ZLEXCOUNT key min max</td><td align="left">在有序集合中计算指定字典区间内成员数量</td></tr><tr><td align="left">ZRANGE key start stop [WITHSCORES]</td><td align="left">通过索引区间返回有序集合成指定区间内的成员</td></tr><tr><td align="left">ZRANGEBYLEX key min max [LIMIT offset count]</td><td align="left">通过字典区间返回有序集合的成员</td></tr><tr><td align="left">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</td><td align="left">通过分数返回有序集合指定区间内的成员</td></tr><tr><td align="left">ZRANK key member</td><td align="left">返回有序集合中指定成员的索引</td></tr><tr><td align="left">ZREM key member [member …]</td><td align="left">移除有序集合中的一个或多个成员</td></tr><tr><td align="left">ZREMRANGEBYLEX key min max</td><td align="left">移除有序集合中给定的字典区间的所有成员</td></tr><tr><td align="left">ZREMRANGEBYRANK key start stop</td><td align="left">移除有序集合中给定的排名区间的所有成员</td></tr><tr><td align="left">ZREMRANGEBYSCORE key min max</td><td align="left">移除有序集合中给定的分数区间的所有成员</td></tr><tr><td align="left">ZREVRANGE key start stop [WITHSCORES]</td><td align="left">返回有序集中指定区间内的成员,通过索引,分数从高到底</td></tr><tr><td align="left">ZREVRANGEBYSCORE key max min [WITHSCORES]</td><td align="left">返回有序集中指定分数区间内的成员,分数从高到低排序</td></tr><tr><td align="left">ZREVRANK key member</td><td align="left">返回有序集合中指定成员的排名,有序集成员按分数值递减(从大到小)排序</td></tr><tr><td align="left">ZSCORE key member</td><td align="left">返回有序集中,成员的分数值</td></tr><tr><td align="left">ZUNIONSTORE destination numkeys key [key …]</td><td align="left">计算给定的一个或多个有序集的并集,并存储在新的 key 中</td></tr><tr><td align="left">ZSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><pre><code class="java">// 首先需要引入 Jedis 库, 启动redis 服务端public static void main(String[] args) {    Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);    System.out.println(jedis.zadd(&quot;zset#score#181229&quot;, 10, &quot;zhaoxi&quot;)); // 1    System.out.println(jedis.zadd(&quot;zset#score#181229&quot;, 20, &quot;yiyi&quot;)); // 1    System.out.println(jedis.zadd(&quot;zset#score#181229&quot;, 30, &quot;wuyu&quot;)); // 1    System.out.println(jedis.zcard(&quot;zset#score#181229&quot;)); // 3    System.out.println(jedis.zincrby(&quot;zset#score#181229&quot;,5,&quot;zhaoxi&quot;)); // 15.0    System.out.println(jedis.zrevrange(&quot;zset#score#181229&quot;, 0, -1)); // [wuyu, yiyi, zhaoxi]    System.out.println(jedis.del(&quot;zset#score#181229&quot;)); //1}</code></pre><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>Redis 的数据结构丰富, 为 Redis 提供了丰富的应用场景. 所以非常受欢迎, 使用中熟练掌握所有结构, 能让我们工作如虎添翼.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>菜鸟教程 <a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/redis/redis-tutorial.html</a></li><li>Redis官网 <a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树的实现原理及应用</title>
      <link href="/2018/12/29/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2018/12/29/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>@<a href="红黑树的实现原理及应用">OTC</a></p><h2 id="什么是红黑树"><a href="#什么是红黑树" class="headerlink" title="什么是红黑树"></a>什么是红黑树</h2><p>红黑树(R-B Tree, 全称 Red-Black Tree)是一种特殊的二叉查找树, 其中每个节点都有颜色, 红色或者黑色.<br>红黑树的特性:</p><ol><li>树的节点是黑色或者红色</li><li>树的根节点和指向null的叶子节点都是黑色</li><li>不能有两个红色节点是连续的</li><li>每个节点至为null的子节点的任何路径, 都含有相同数量的黑色节点</li></ol><p>示例:</p><pre><code class="java">             8B            / \           4R  9B          /  \        2B    6B       /  \   / \      1R  3R 5R  7R</code></pre><h2 id="红黑树的应用和时间复杂度"><a href="#红黑树的应用和时间复杂度" class="headerlink" title="红黑树的应用和时间复杂度"></a>红黑树的应用和时间复杂度</h2><ol><li>主要是 Java 中的 TreeMap 和 TreeSet. jdk1.8 之后, HashMap 的table中的链表长度大于8的时候也是用 红黑树.</li><li>时间复杂度: 查找, 插入, 删除都可以在 O(log n) 内完成. 且节点数为 n 的数高度最大为 2log(n+1).</li></ol><h2 id="红色树的操作"><a href="#红色树的操作" class="headerlink" title="红色树的操作"></a>红色树的操作</h2><h4 id="节点的基本定义"><a href="#节点的基本定义" class="headerlink" title="节点的基本定义"></a>节点的基本定义</h4><pre><code class="java">    //节点定义    public class RBTNode&lt;T extends Comparable&lt;T&gt;&gt; {        public boolean isBlack;        public T key;        public RBTNode&lt;T&gt; parent;        public RBTNode&lt;T&gt; left;        public RBTNode&lt;T&gt; right;        public RBTNode(T key, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right, boolean isBlack) {            this.isBlack = isBlack;            this.key = key;            this.parent = parent;            this.left = left;            this.right = right;        }        public String toString() {            return &quot;key: &quot; + key + (isBlack ? &quot; B &quot; : &quot; R &quot;) +                    (parent != null ? (                            ((parent.left != null &amp;&amp; parent.left == this) ?                                    parent.key + &quot; Left&quot; :                                    (parent.right != null &amp;&amp; parent.right == this) ?                                    parent.key + &quot; Right&quot; : &quot;&quot;))                            : &quot;&quot;);        }    }</code></pre><h4 id="旋转-左旋转的两种情况"><a href="#旋转-左旋转的两种情况" class="headerlink" title="旋转 - 左旋转的两种情况"></a>旋转 - 左旋转的两种情况</h4><p>旋转的中心思想是: 从新设置 x 节点, y 节点的 左 父 右 节点, 并设置关联变化的节点的父节点.</p><pre><code class="java">    px                   px             |                px                    px                          \                    \             |               /                     /                        x                    y            |              x           -&gt;        y                                      / \      -&gt;          / \           |             / \                   / \                          lx   y                x  ry          |            lx  y                 x   ry                               / \              / \             |               / \               / \                                ly  ry            lx  ly           |              ly  ry            lx ly                           // 对 x 进行左旋转, 将 x 是 y 的父节点变成, y 是 x 的父节点.    private void rotateLeft(RBTNode&lt;T&gt; x) {        RBTNode&lt;T&gt; y = x.right;        // 1. 设置x 的 左 父 右 节点        // 1-1 x的左节点无变化        // 1-2 x的右节点, 设置x右节点的父节点        x.right = y.left;        if(y.left != null) y.left.parent = x;        // 1-3 x的父节点无变化        //2. 设置y 的 左 父 右 节点        //2-1: 设置y的父节点        y.parent = x.parent;        if (x.parent == null) this.root = y;        else if (x.parent.left == x) x.parent.left = y;        else x.parent.right = y;        //2-2: 设置y 的左节点        y.left = x;        x.parent = y;        //2-3: y节点的右节点无变化    }</code></pre><h4 id="旋转-右旋转的两种情况"><a href="#旋转-右旋转的两种情况" class="headerlink" title="旋转 - 右旋转的两种情况"></a>旋转 - 右旋转的两种情况</h4><pre><code class="java">          py                py         |              py                   py                    /                 /           |               \                    \                 y                 x            |                y        -&gt;          x               / \        -&gt;     / \           |               / \                  / \             x   ry           lx   y          |              x  ry               lx   y           / \                   / \         |             / \                      / \         lx rx                 rx  ry       |            lx rx                    rx  ry       // 对 y 进行右旋转, 将 y 是 x 的父节点 变成 x 是 y 的父节点                                                                                                                      private void rotateRight(RBTNode&lt;T&gt; y) {        RBTNode&lt;T&gt; x = y.left;        //1: 设置y 的左 父 右 节点        //1-1: 设置y 的左节点, 并设置其父节点        y.left = x.right;        if (x.right != null) x.right.parent = y;        //2-2: 设置x的父节点        x.parent = y.parent;        //1-3: y的右节点无变化        //2: 设置x 的左 右 父节点        //2-2: 设置x 的父节点, 及其父节点的子节点        if (y.parent == null) this.root = x;        else if (y == y.parent.right) y.parent.right = x;        else y.parent.left = x;        //2-1: 设置 x的右节点, 并设置其父节点        x.right = y;        //1-2: 设置y 的父节点        y.parent = x;        //2-3 x的左节点无变化    }</code></pre><h4 id="插入并修正"><a href="#插入并修正" class="headerlink" title="插入并修正"></a>插入并修正</h4><ol><li>若root 是null , 则插入节点就是root 节点.</li><li>若root 不是null, 则向下查找node 的父节点, 并根据与父节点的大小关系, 写入待插入节点. 插入的节点都是红色</li><li>修正插入的树.</li><li>修正过程, 修正的核心思想是: 将红色节点移动到根节点, 将根节点设为黑色.</li></ol><table><thead><tr><th align="center">违背原则4</th><th align="left">现象说明</th><th align="left">处理策略</th></tr></thead><tbody><tr><td align="center">情况1</td><td align="left">isRed(parent), isRed(uncle)</td><td align="left">1. setBlack(parent);<br> 2. setBlack(uncle); <br>3. setRed(grandParent);<br> 4. current = grandParent;<br>5. 检测 current 是否违背原则并处理</td></tr><tr><td align="center">情况2</td><td align="left">isRed(parent), isBlack(uncle), uncle == grandParent.left, current == parent.right</td><td align="left">1. setBlack(parent);<br> 2. setRed(grandParent);<br> 3. rotateLeft(grandParent);</td></tr><tr><td align="center">情况3</td><td align="left">isRed(parent), isBlack(uncle), uncle == grandParent.left, current == parent.left</td><td align="left">1. current = parent;<br> 2. rotateRight(current);<br> 3. 检测 current 是否违背原则并处理</td></tr><tr><td align="center">情况4</td><td align="left">isRed(parent), isBlack(uncle), uncle == grandParent.right, current == parent.right</td><td align="left">1. current = parent;<br> 2. rotateLeft(current);<br> 3. 检测 current 是否违背原则并处理</td></tr><tr><td align="center">情况5</td><td align="left">isRed(parent), isBlack(uncle), uncle == grandParent.right, current == parent.left</td><td align="left">1. setBlack(parent);<br> 2. setRed(grandParent);<br> 3. rotateRight(grandParent);</td></tr></tbody></table><pre><code class="java">    // 插入修正    private void insertFix(RBTNode&lt;T&gt; node) {        RBTNode&lt;T&gt; parent;        RBTNode&lt;T&gt; grandParent;        while (isRed(parentOf(node))) {            parent = parentOf(node);            grandParent = parentOf(parent);            RBTNode&lt;T&gt; uncle;            if (parent == grandParent.left) {                uncle = grandParent.right;                if (isRed(uncle)) {  // 情况 1                    setBlack(parent);                    setBlack(uncle);                    setRed(grandParent);                    node = grandParent;                    continue;                }                if (isBlack(uncle)) {                    if (parent.right == node) { // 情况 4                        node = parent;                        rotateLeft(grandParent);                    } else { // 情况 5                        setBlack(parent);                        setRed(grandParent);                        rotateRight(grandParent);                    }                }            } else {                uncle = grandParent.left;                if (isRed(uncle)) { // 情况 1                    setBlack(uncle);                    setBlack(parent);                    setRed(grandParent);                    node = grandParent;                    continue;                }                if (isBlack(uncle)) {                    if (parent.left == node) { // 情况 2                        node = parent;                        rotateRight(node);                    } else { // 情况 3                        setBlack(parent);                        setRed(grandParent);                        rotateLeft(grandParent);                    }                }            }        }     }       // 插入    public void insert(RBTNode&lt;T&gt; node) {        if (this.root == null) {            this.root = node;        } else {            int compare = 0;            RBTNode&lt;T&gt; temp = null;            RBTNode&lt;T&gt; current = this.root;            //1. 先查找二叉树, 确定node的插入位置            while (current != null) {                temp = current;                compare = node.getKey().compareTo(current.getKey());                if (compare &lt; 0) current = current.getLeft();                 else current = current.getRight();             }            node.setParent(temp);            compare = node.getKey().compareTo(temp.getKey());            if (compare &lt; 0) temp.setLeft(node);            else temp.setRight(node);        }         insertFix(node);        setBlack(root);    } </code></pre><h4 id="删除并修正"><a href="#删除并修正" class="headerlink" title="删除并修正"></a>删除并修正</h4><ol><li>核心思想: 将被删节点所包含的额外黑色节点(右节点)不断往根节点方向移动并按照情况修正</li><li>修正的方法</li></ol><table><thead><tr><th align="center">情况</th><th align="left">现象说明</th><th align="left">处理策略</th></tr></thead><tbody><tr><td align="center">情况1</td><td align="left">isRed(current)&amp;&amp;isBlack(brother) or isRed(brother)&amp;&amp;isBlack(current)</td><td align="left">1. setBlack(current);<br> 2. 执行核心思想移动其子节点</td></tr><tr><td align="center">情况2</td><td align="left">isBlack(current) isBlack(brother) current==root</td><td align="left">执行核心思想移动子节点</td></tr><tr><td align="center">情况3</td><td align="left">isBlack(current) isBlack(brother) current!=root</td><td align="left">执行下面4中情况</td></tr><tr><td align="center">情况3-1</td><td align="left">isRed(brother)</td><td align="left">1. setBlack(brother);<br> 2. setRed(parent);<br> 3. rotateLeft(parent);<br> 4. 重新设置current的brother</td></tr><tr><td align="center">情况3-2</td><td align="left">isBlack(brother), isBlack(brother.left), isBlack(brother.right)</td><td align="left">1. setRed(brother);<br> 2. current = parent</td></tr><tr><td align="center">情况3-3</td><td align="left">isBlack(brother), isBlack(brother.right), isRed(brother.left)</td><td align="left">1. setBlack(brother.left);<br> 2. setRed(brother);<br> 3. rotateRight(brother);<br> 4. 重新设置current的brother</td></tr><tr><td align="center">情况3-4</td><td align="left">isBlack(brother), isRed(brother.right)</td><td align="left">1. brother.color = parent.color;<br> 2. setBlack(parent);<br> 3. setBlack(brother.right);<br> 4. rotateLeft(brother);<br> 5. root = x</td></tr></tbody></table><h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><pre><code class="java">public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; {    private RBTNode&lt;T&gt; root;    public void preOrder() {        preOrder(root);    }    private void preOrder(RBTNode&lt;T&gt; node) {        if (node != null) {            System.out.println(node + &quot; &quot;);            preOrder(node.left);            preOrder(node.right);        }    }    public void inOrder() {        inOrder(root);    }    private void inOrder(RBTNode&lt;T&gt; node) {        if (node != null) {            inOrder(node.left);            System.out.println(node.toString());            inOrder(node.right);        }    }    public void postOrder() {        postOrder(root);    }    private void postOrder(RBTNode&lt;T&gt; node) {        if (node != null) {            preOrder(node.left);            preOrder(node.right);            System.out.println(node + &quot; &quot;);        }    }    public void insert(T key) {        insert(new RBTNode&lt;T&gt;(key, null, null, null, false));    }    private void insert(RBTNode&lt;T&gt; node) {     }    private RBTNode&lt;T&gt; parentOf(RBTNode&lt;T&gt; x) {        return (x == null ? null : x.parent);    }    private boolean isRed(RBTNode&lt;T&gt; x) {        if (x == null) return false;        return !x.isBlack;    }    private boolean isBlack(RBTNode&lt;T&gt; x) {        return (x == null || x.isBlack);    }    private void setRed(RBTNode&lt;T&gt; x) {        if (x != null)            x.isBlack = false;    }    private void setBlack(RBTNode&lt;T&gt; x) {        if (x != null)            x.isBlack = true;    }    private void insertFix(RBTNode&lt;T&gt; node) {     }    private void rotateRight(RBTNode&lt;T&gt; y) {    }    private void rotateLeft(RBTNode&lt;T&gt; x) {     }    public void remove(RBTNode&lt;T&gt; node) {    }}//测试代码public static void main(String[] args) {        RBTree&lt;Integer&gt; tree = new RBTree&lt;&gt;();        int[] arr = new int[]{9, 8, 3, 5, 4, 2, 7, 6, 1};        for (int item : arr)            tree.insert(9);        System.out.println(&quot;前序&quot;);        tree.preOrder();        System.out.println(&quot;----------------------&quot;);        System.out.println(&quot;中序&quot;);        tree.inOrder();        System.out.println(&quot;----------------------&quot;);        System.out.println(&quot;后序&quot;);        tree.postOrder();    }// 前序// key: 8 B  // key: 4 R 8 Left // key: 2 B 4 Left // key: 1 R 2 Left // key: 3 R 2 Right // key: 6 B 4 Right // key: 5 R 6 Left // key: 7 R 6 Right // key: 9 B 8 Right // ----------------------// 中序// key: 1 R 2 Left// key: 2 B 4 Left// key: 3 R 2 Right// key: 4 R 8 Left// key: 5 R 6 Left// key: 6 B 4 Right// key: 7 R 6 Right// key: 8 B // key: 9 B 8 Right// ----------------------// 后序// key: 4 R 8 Left // key: 2 B 4 Left // key: 1 R 2 Left // key: 3 R 2 Right // key: 6 B 4 Right // key: 5 R 6 Left // key: 7 R 6 Right // key: 9 B 8 Right // key: 8 B  </code></pre><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://sandbox.runjs.cn/show/2nngvn8w" target="_blank" rel="noopener">https://sandbox.runjs.cn/show/2nngvn8w</a></li><li><a href="http://www.cnblogs.com/skywang12345/p/3624343.html" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3624343.html</a></li><li><a href="http://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3245399.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC的请求处理流程</title>
      <link href="/2018/12/27/Spring-MVC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/12/27/Spring-MVC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="DispatcherServlet的处理流程图"><a href="#DispatcherServlet的处理流程图" class="headerlink" title="DispatcherServlet的处理流程图"></a>DispatcherServlet的处理流程图</h2><p><img src="/.io//1.png" alt="DispatcherServlet的处理流程"></p><h2 id="核心处理流程步骤"><a href="#核心处理流程步骤" class="headerlink" title="核心处理流程步骤"></a>核心处理流程步骤</h2><ol><li>检测是否是文件上传, 并处理</li><li>根据 Request 获取 HandlerExecutionChain<br>2-1: 首先解析 Request 的请求的Path<br>2-2: 根据 Path 在返回 HanlderMethod<br>2-3: 将 HanlderMethod + HandlerInterceptor 包装成 HandlerExecutionChain 返回.</li><li>执行Chain的preHanlde方法</li><li>根据Chain的HandlerMethod, 调用对应的Controller的method, 并返回ModelAndView对象(如果ModelAndView对象为null或者没有View, 那么直接使用默认实现值返回).</li><li>执行Chain的postHandle方法</li><li>根据vm返回值渲染页面<br>6-1: 根据viewName解析View对象<br>6-2: 根据view对象渲染页面</li></ol><pre><code class="java">// 从代码中解读protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        HttpServletRequest processedRequest = request;        HandlerExecutionChain mappedHandler = null;        boolean multipartRequestParsed = false;        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);        try {            try {                ModelAndView mv = null;                Object dispatchException = null;                try {                    processedRequest = this.checkMultipart(request); // 步骤1                    multipartRequestParsed = processedRequest != request;                    mappedHandler = this.getHandler(processedRequest); // 步骤2                    if (mappedHandler == null) {                        this.noHandlerFound(processedRequest, response);                        return;                    }                    HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());                    String method = request.getMethod();                    boolean isGet = &quot;GET&quot;.equals(method);                    if (isGet || &quot;HEAD&quot;.equals(method)) {                        long lastModified = ha.getLastModified(request, mappedHandler.getHandler());                        if (this.logger.isDebugEnabled()) {                            this.logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);                        }                        if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) {                            return;                        }                    }                    if (!mappedHandler.applyPreHandle(processedRequest, response)) { // 步骤3                        return;                    }                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); // 步骤4                     if (asyncManager.isConcurrentHandlingStarted()) {                        return;                    }                    this.applyDefaultViewName(processedRequest, mv);  // 步骤5                     mappedHandler.applyPostHandle(processedRequest, response, mv);                } catch (Exception var20) {                    dispatchException = var20;                } catch (Throwable var21) {                    dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, var21);                }                this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException); //步骤6             } catch (Exception var22) {                this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);            } catch (Throwable var23) {                this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, var23));            }        } finally {            if (asyncManager.isConcurrentHandlingStarted()) {                if (mappedHandler != null) {                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);                }            } else if (multipartRequestParsed) {                this.cleanupMultipart(processedRequest);            }        }    }</code></pre><h2 id="DispatcherServlet-的初始化过程"><a href="#DispatcherServlet-的初始化过程" class="headerlink" title="DispatcherServlet 的初始化过程"></a>DispatcherServlet 的初始化过程</h2><ol><li><p>initMultipartResolver: 文件上传处理器<br> 从容器中获取名为multipartResolver的Bean做该类型的组件, 没有则不拥有该类型组件<br> 默认实现: 没有默认实现</p></li><li><p>initLocaleResolver: 国际化处理器<br> 从容器中获取名为localeResolver的Bean做该类型的组件, 没有则调用默认实现<br> 默认实现: org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</p></li><li><p>initThemeResolver: 主题管理处理器 对应容器中的Bean是: themeResolver<br> 从容器中获取名为themeResolver的Bean做该类型的组件, 没有则调用默认实现<br> 默认实现: org.springframework.web.servlet.theme.FixedThemeResolver</p></li><li><p>initHandlerMappings: 处理映射器 主要做url到处理类的映射<br> 如果 detectAllHandlerMappings = true (默认实现), 查找类型匹配机制及父Spring容器中类型为HanlderMapping的Bean, 作为该类型组件<br> 否则 查找名称为handlerMapping的Bean, 作为该类型的组件<br> 如果都没有找到, 则调用默认实现<br> 默认实现:  </p><pre><code> 1. org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping() 2. org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</code></pre></li><li><p>initHandlerAdapters: 处理适配器 处理器的真正实现<br> 如果 detectAllHandlerAdapters = true (默认实现), 查找类型匹配机制及父Spring容器中类型为HandlerAdapter的Bean, 作为该类型组件<br> 否则 查找名称为handlerAdapter的Bean, 作为该类型的组件<br> 如果都没有找到, 则调用默认实现<br> 默认实现:</p><pre><code> 1. org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter 2. org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter 3. org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</code></pre></li><li><p>initHandlerExceptionResolvers: 异常处理器<br> 如果 detectAllHandlerExceptionResolvers = true (默认实现), 查找类型匹配机制及父Spring容器中类型为HandlerAdapter的Bean, 作为该类型组件<br> 否则 查找名称为handlerExceptionResolver的Bean, 作为该类型的组件<br> 如果都没有找到, 则调用默认实现<br> 默认实现:</p><pre><code> 1. org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver 2. org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver 3. org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</code></pre></li><li><p>initRequestToViewNameTranslator: 视图名称翻译器<br> 查找名称为viewNameTranslator的Bean作为该类型的组件, 没有则调用默认实现<br> 默认实现: org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</p></li><li><p>initViewResolvers: 视图解析器<br> 如果 detectAllViewResolvers = true (默认实现), 查找类型匹配机制及父Spring容器中类型为HandlerAdapter的Bean, 作为该类型组件<br> 否则 查找名称为viewResolver的Bean, 作为该类型的组件<br> 如果都没有找到, 则调用默认实现<br> 默认实现: org.springframework.web.servlet.view.InternalResourceViewResolver</p></li><li><p>initFlashMapManager: 重定向数据管理器<br>查找名称为flashMapManager的Bean作为该类型的组件, 没有则调用默认实现<br>默认实现: org.springframework.web.servlet.support.SessionFlashMapManager</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring mvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean的作用域和生命周期</title>
      <link href="/2018/12/26/Spring-Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/12/26/Spring-Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring中5种作用域"><a href="#Spring中5种作用域" class="headerlink" title="Spring中5种作用域"></a>Spring中5种作用域</h2><p>在Spring配置Bean时, 可以通过设置scope属性来定义Bean的作用域, 按照scope的值来分, Bean的作用域分为以下几种:</p><ol><li>[基本作用域]singeton: 单例模式(默认方式), 每次返回同一个对象实例. 通过设置其 lazy-init参数可以设置是否延迟生成对象, 并将该对象存储在内部的ConcurrentHashMap中.</li><li>[基本作用域]prototype: 原型模式, 每次都返回一个新的对象实例. 每次获取时才回去创建该对象.</li><li>[Spring的Web作用域]request: 同一次请求返回同一个对象实例.</li><li>[Spring的Web作用域]session: 同一次会话返回同一个对象实例.</li><li>[Spring的Web作用域]global-session: 所有会话返回同一个对象实例.</li></ol><h2 id="基本作用域的使用"><a href="#基本作用域的使用" class="headerlink" title="基本作用域的使用"></a>基本作用域的使用</h2><p>需要引入spring-core, spring-bean</p><pre><code class="java">public class ScopeDemo {    public static void main(String[] args) {        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Scope.xml&quot;);        System.out.println(&quot;singleton: &quot; + (context.getBean(SingetonBean.class) == context.getBean(SingetonBean.class)));        System.out.println(&quot;prototype: &quot; + (context.getBean(PrototypeBean.class) == context.getBean(PrototypeBean.class)));        System.out.println(&quot;default: &quot; + (context.getBean(DefaultBean.class) == context.getBean(DefaultBean.class)));        // 输出 :         // singleton: true        // prototype: false        // default: true    }}class DefaultBean {}class SingetonBean {}class PrototypeBean {}//Spring-Scope.xml 文件放入resources文件夹中&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean class=&quot;fun.zhaoxi.scope.SingetonBean&quot; scope=&quot;singleton&quot;/&gt;    &lt;bean class=&quot;fun.zhaoxi.scope.PrototypeBean&quot; scope=&quot;prototype&quot;/&gt;    &lt;bean class=&quot;fun.zhaoxi.scope.DefaultBean&quot;/&gt;&lt;/beans&gt;</code></pre><h2 id="基本作用域Bean的生命周期"><a href="#基本作用域Bean的生命周期" class="headerlink" title="基本作用域Bean的生命周期"></a>基本作用域Bean的生命周期</h2><p>从源码(版本 5.0.4)解读, Bean的生命周期的入口是getBean()方法, 大概分为以下的步骤:</p><ol><li>当容器启动时, 会扫描所有的Bean信息, 并存储起来, 如果有Singleton的bean且没有设置延迟加载, 那么直接执行下面的初始化过程并缓存.</li><li>如果传入参数是类型为Class ,那么首先解析该Bean的名字, 默认BeanName = 类的全名; 如果传入名字是BeanName那么直接使用.</li><li>首先从步骤1的缓存中根据Key=BeanName读取Bean对象, 如果有直接返回.</li><li>如果没有的话, 就检测其父工厂是否包含该Bean, 如果有, 直接返回.</li><li>检测当前Bean是否有依赖Bean, 如果有依赖Bean, 首先构造依赖的Bean.</li><li>检测当前Bean的作用域, 如果是Singleton, 那么直接开始构造Bean; 如果是Prototype, 则现将当前BeanName写入到循环依赖检测的ThreadLocal<object>中(构造完成后从ThreadLocal<object>中移除), 再开始构造Bean.</object></object></li><li>开始真正的创建Bean:<br>7-1: 构造Bean调用其构造函数(工厂方法)构造对象并设置其属性值(如果属性值, 构造函数参数是复杂对象, 先构造这些复杂参数)<br>7-2: 如果BeanClass实现了BeanNameAware, 那么执行其setBeanName()方法<br>7-3: 如果BeanClass实现了BeanClassLoaderAware, 那么执行其setBeanClassLoader()方法<br>7-4: 如果BeanClass实现了BeanFactoryAware, 那么执行其setBeanFactory()方法<br>7-5: 执行BeanPostProcessors的postProcessBeforeInitialization方法, 返回后置处理器包装后的Bean, 如果没有直接返回当前Bean<br>7-6: 执行bean的init-method方法<br>7-7: 执行BeanPostProcessors的postProcessAfterInitialization方法, 返回处理器包装后的Bean, 没有直接返回当前Bean<br>7-8: 真正返回Bean</li><li>当容器关闭的时候, 执行Bean的destroy-method方法.</li></ol><h2 id="验证基本作用域生命周期"><a href="#验证基本作用域生命周期" class="headerlink" title="验证基本作用域生命周期"></a>验证基本作用域生命周期</h2><pre><code class="java">class DemoBean implements BeanNameAware, BeanClassLoaderAware, BeanFactoryAware {    private String name;    public DemoBean() {        System.out.println(&quot;ctor&quot;);    }    public void setName(String name) {        this.name = name;        System.out.println(&quot;set name &quot; + name);    }    public void init() {        System.out.println(&quot;bean init&quot;);    }    public void destroy() {        System.out.println(&quot;bean destroy&quot;);    }    public void setBeanName(String name) {        System.out.println(&quot;set bean name &quot; + name);    }    public void setBeanClassLoader(ClassLoader classLoader) {        System.out.println(&quot;set bean ClassLoader &quot;);    }    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {        System.out.println(&quot;set bean Factory &quot;);    }}class DemoBeanPostProcessor implements BeanPostProcessor {    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {        System.out.println(beanName + &quot; postProcessBeforeInitialization &quot;);        return bean;    }    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        System.out.println(beanName + &quot; postProcessAfterInitialization &quot;);        return bean;    }}//Spring-Scope.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;     &lt;bean id=&quot;demoBean&quot; class=&quot;fun.zhaoxi.scope.DemoBean&quot; init-method=&quot;init&quot;     destroy-method=&quot;destroy&quot; scope=&quot;prototype&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;demoBean-name&quot;/&gt;    &lt;/bean&gt;     &lt;bean class=&quot;fun.zhaoxi.scope.DemoBeanPostProcessor&quot;/&gt;&lt;/beans&gt;public class ScopeDemo {    public static void main(String[] args) {        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-Scope.xml&quot;);        context.getBean(&quot;demoBean&quot;);         ((ClassPathXmlApplicationContext) context).close();    }}// 输出:// ctor// set name demoBean-name// set bean name demoBean// set bean ClassLoader // set bean Factory // demoBean postProcessBeforeInitialization // bean init// demoBean postProcessAfterInitialization</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bean scope </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring中的两种aop实现方式jdk动态代理和cglib代理</title>
      <link href="/2018/12/25/spring%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8Daop%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8Fjdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccglib%E4%BB%A3%E7%90%86/"/>
      <url>/2018/12/25/spring%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8Daop%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8Fjdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccglib%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="aop的概念"><a href="#aop的概念" class="headerlink" title="aop的概念"></a>aop的概念</h2><p>aop (Aspect Oriented Programming), 直译: 面向侧面编程, 通过 预编译方式 或者 动态代理 实现程序功能的统一维护的一种技术<br>带来的好处是: 可以对通用的业务逻辑独立, 降低通用逻辑和业务逻辑的耦合, 提高通用逻辑的重用性, 提高开发效率.</p><h2 id="主要应用"><a href="#主要应用" class="headerlink" title="主要应用"></a>主要应用</h2><p>统一日志记录, 性能统计, 统一授权, 事务处理, 统一异常处理.</p><h2 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>实现利用java.lang.reflect.InvocationHandler接口, 重写其invoke方法为方法批量添加统一业务. </p><pre><code class="java">interface UserService {    void insert(String userName);}class UserServiceImpl implements UserService {    public void insert(String userName) {        System.out.println(&quot;insert &quot; + userName);    }}class UserServiceProxy implements InvocationHandler {    private Object target;    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;before insert&quot;);        Object result = method.invoke(target, args);        System.out.println(&quot;after insert&quot;);        return result;    }    public Object getProxy(Object target) {        this.target = target;        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);    }}public class CglibAopDemo {     public static void main(String[] args) {        UserService userService = new UserServiceImpl();        userService.insert(&quot;zhaoxi&quot;);// 只输出 insert zhaoxi        UserServiceProxy proxy = new UserServiceProxy();        UserService userServiceProxy = (UserService) proxy.getProxy(userService);        userServiceProxy.insert(&quot;zhaoxi&quot;);        //输出: before insert        //insert zhaoxi        //after insert    }} </code></pre><h4 id="动态代理的代理类生成过程"><a href="#动态代理的代理类生成过程" class="headerlink" title="动态代理的代理类生成过程"></a>动态代理的代理类生成过程</h4><ol><li>根据传入的ClassLoader和接口生成接口代理类的字节码</li><li>将自定义InvocationHandler对象作为代理类构造函数的参数, 传入代理类获取代理类的构造器</li><li>根据构造器来生成代理类的对象实例</li></ol><h4 id="jdk动态代理的注意事项"><a href="#jdk动态代理的注意事项" class="headerlink" title="jdk动态代理的注意事项"></a>jdk动态代理的注意事项</h4><ol><li>由于代理类继承了Proxy类, java不支持多继承, 所有只能代理接口, 不能代理类. </li></ol><h2 id="cglib代理"><a href="#cglib代理" class="headerlink" title="cglib代理"></a>cglib代理</h2><h4 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h4><p>使用CGLIB库, 实现库中MethodInterceptor 接口为方法添加统一业务<br>使用时需单独引入CGLIB库</p><pre><code class="java">class UserServiceCglib implements MethodInterceptor {    private Object target;    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;before insert cglib&quot;);        Object result = methodProxy.invokeSuper(o, objects);        System.out.println(&quot;after insert cglib&quot;);        return result;    }    public Object getTarget(Object target) {        this.target = target;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(this.target.getClass());        enhancer.setCallback(this);        return enhancer.create();    }}public static void main(String[] args) {    UserService userService = new UserServiceImpl();    UserService userServiceProxy = (UserService) new UserServiceCglib().getTarget(userService);    userServiceProxy.insert(&quot;zhaoxi&quot;);    //输出 before insert cglib    //insert zhaoxi    //after insert cglib}</code></pre><h4 id="cglib代理的注意实现"><a href="#cglib代理的注意实现" class="headerlink" title="cglib代理的注意实现"></a>cglib代理的注意实现</h4><ol><li>需要单独引入CGLIB库</li><li>不需要类继承接口, 但是不能将类设置为final, 因为使用继承生成代理.</li></ol><h2 id="Spring中的aop概念"><a href="#Spring中的aop概念" class="headerlink" title="Spring中的aop概念"></a>Spring中的aop概念</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>Joinpoint : 连接点(在哪里), 在什么地方执行 增强操作, spring只支持方法级的连接点.</li><li>Pointcut : 切点是一组连接点的集合(在哪里干的集合).<ol><li>切点表达式介绍  execution(* fun.zhaoxi.aop..<em>.</em>(..))</li><li>execution() 是表达式的主体</li><li>括号中第一个 * 是方法的返回值, * 代表所有</li><li>fun.zhaoxi.aop.. 前面是包名的前缀, .. 代表子包和孙包中的所有类</li><li><em>.</em> 代表类名和方法名, * 代表所有</li><li>(..) 代表方法中的参数, .. 代表所有</li></ol></li><li>Advice : 增强(干什么), 一般是我们的公共业务.</li><li>Aspect : 切面(在哪儿干和干什么的集合), SpringAop就是负责操作切面并执行.<br>  切面类型:  <ol><li>@Before 前置通知</li><li>@After 后置通知</li><li>@AfterReturning 目标方法执行结束后执行</li><li>@AfterThrowing 目标方法异常执行</li><li>@Around 环绕通知, 目标方法执行前后都执行<br>目标方法正确的执行顺序是<br>5 → 1 → target() → 5 → 2 → 3.</li></ol></li></ul><h4 id="切面的示例"><a href="#切面的示例" class="headerlink" title="切面的示例"></a>切面的示例</h4><p>下面示例需要引入 spring-core, spring-context, spring-beans, spring-aop, spring-aspects 包<br>默认使用SDK动态代理, 如果使用CGLIB代理, 需要单独引入CGLIB库.</p><pre><code class="java">interface UserService {    void insert(String userName);}@Componentclass UserServiceImpl implements UserService {    public void insert(String userName) {        System.out.println(&quot;insert &quot; + userName);    }}@Component@Aspect // 切面class UserServiceAspect {     @Pointcut(&quot;execution(* fun.zhaoxi.aop.*.*(..))&quot;) //切点 参数为切点表达式    public void pointcut() {    }    @Before(&quot;pointcut()&quot;)    public void insertBefore() { //增强        System.out.println(&quot;spring aop insert before&quot;);    }    @After(&quot;pointcut()&quot;)    public void insertAfter() { //增强        System.out.println(&quot;spring aop insert after&quot;);    }    @Around(&quot;pointcut()&quot;)    public void insertAround(ProceedingJoinPoint point) throws Throwable { //增强        System.out.println(&quot;spring aop insert around before&quot;);        point.proceed();        System.out.println(&quot;spring aop insert around after&quot;);    }    @AfterReturning(&quot;pointcut()&quot;)    public void insertAfterReturning() { //增强        System.out.println(&quot;spring aop insert afterReturning&quot;);    }    @AfterThrowing(&quot;pointcut()&quot;)    public void insertAfterThrow() { //增强        System.out.println(&quot;spring aop insert afterThrow&quot;);    }}//spring-aop.xml: 放入resources文件夹&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;aop:aspectj-autoproxy/&gt; &lt;!-- 如果要使用cglib代理, 添加 proxy-target-class=&quot;true&quot;, 需引入 cglib 包 --&gt;    &lt;context:component-scan base-package=&quot;fun.zhaoxi.aop&quot; /&gt;&lt;!-- 包名是 service的包名 --&gt;&lt;/beans&gt;public static void main(String[] args) {    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-aop.xml&quot;);    UserService userService = applicationContext.getBean(UserService.class);    userService.insert(&quot;zhaoxi&quot;);}//输出:// spring aop insert around before// spring aop insert before// insert zhaoxi// spring aop insert around after// spring aop insert after// spring aop insert afterReturning</code></pre><h2 id="spring的aop总结"><a href="#spring的aop总结" class="headerlink" title="spring的aop总结"></a>spring的aop总结</h2><p>aop是spring的核心功能之一, 要玩转spring, 肯定要深入了解.<br>在spring中 缓存, 错误处理, 事务, 等等功能都有aop的身影, 但是真正能发挥强大功能的是 ioc + aop.</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Map的比较与实现(jdk1.8+)</title>
      <link href="/2018/12/24/%E5%B8%B8%E7%94%A8Map%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E5%AE%9E%E7%8E%B0-jdk1-8/"/>
      <url>/2018/12/24/%E5%B8%B8%E7%94%A8Map%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E5%AE%9E%E7%8E%B0-jdk1-8/</url>
      
        <content type="html"><![CDATA[<h2 id="常用的Map比较"><a href="#常用的Map比较" class="headerlink" title="常用的Map比较"></a>常用的Map比较</h2><table><thead><tr><th align="center">比较项</th><th align="center">ConcurrentHashMap</th><th align="center">HashTable</th><th align="center">HashMap</th><th align="center">TreeMap</th></tr></thead><tbody><tr><td align="center">线程安全</td><td align="center">是</td><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">线程安全方式</td><td align="center">锁分段技术1.7 / CAS+synchronized1.8</td><td align="center">方法synchronized</td><td align="center">不安全</td><td align="center">不安全</td></tr><tr><td align="center">Key可以为null</td><td align="center">否</td><td align="center">否</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">Value可以为null</td><td align="center">否</td><td align="center">否</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">继承自</td><td align="center">AbstractMap</td><td align="center">Dictionary</td><td align="center">AbstractMap</td><td align="center">AbstractMap</td></tr></tbody></table><h2 id="HashMap-的实现"><a href="#HashMap-的实现" class="headerlink" title="HashMap 的实现"></a>HashMap 的实现</h2><pre><code class="java">    // hashmap 的整体结构    A[0]       A[1]       A[2]       A[3]       RBTR[4]       A[5]      ↓          ↓          ↓          ↓          ↓             ↓    null      A[1-1]      null      A[3-1]     RBTR[4-1]      null                    ↓                     ↓        ...(超过8)                 A[1-2]                null     RBTR[4-n] RBTR[4-m]      数组的元素结构    class Node{ //链表        0,1,2,3,5 的数据结构               K Key;        V Value;        int hash;        Node next;    }   class TreeNode{ //红黑树     4的数据结构        TreeNode parent;        TreeNode left;        TreeNode right;        TreeNode prev;        boolean red;     }</code></pre><p>HashMap的整体结构就是 数组 + 链表(元素少于8使用链表, 元素大于8使用红黑树).<br>数组串起来了HashMap的主体, 链表则为了解决hash冲突的问题.</p><h4 id="put-K-key-V-value-方法的主要执行过程"><a href="#put-K-key-V-value-方法的主要执行过程" class="headerlink" title="put(K key, V value) 方法的主要执行过程"></a>put(K key, V value) 方法的主要执行过程</h4><ol><li>首先计算key的hashcode. 调用了key自身的hashCode() 方法. 所以所有插入HashMap 的Key都必须重写其hashCode方法和equels方法.<br> 拓展: 一个自定义类作为Key时, 必须同时重写equals方法和hashCode.<pre><code>  推荐使用String 来作为Key, 其优点是 String 是不可变的, 并且已经实现了 equals 和 hashCode 方法.  如果不重写这两个方法, 可能引发的就是高几率hash碰撞, 导致性能问题.</code></pre></li><li>如果数组没有初始化, 那么调用默认初始化, 长度 16, 阈值为16 * 0.75(默认的阈值因子)</li><li>根据当前Key的 HashCode 与 (数组长度-1) 做并集的结果 作为数组下标查找, 如果没有查找到值, 那么直接插入Node.</li><li>如果hash碰撞, 根据 数组现有元素 进行判断数据处理<br>4-1 : 如果插入值与 数组现有元素 hash 值相同, key 也相同, equal 方法也相同, 那么说明是插入重复值.<br>4-2 : 如果 数组现有元素 是 TreeNode类型(红黑树节点), 那么直接插入节点到红黑树.<br>4-3 : 如果 Hash 碰撞的值小于插入 转化为 红黑树的阈值 (默认8个), 那么直接如插入链表尾部, 否则将链表转化为 红黑树. 所有该hash值的key转为TreeNode.</li><li>如果当前的map的元素数量超过阈值(初始化阈值 16 * 0.75 = 12), 那么调整数组的大小, 也叫rehashing.<br>5-1 : 如果数组大小已经超过默认最大值 (1&lt;&lt;30), 不再变动<br>5-2 : 没有超过默认最大值, 将数组的容量 * 2.<br>5-3 : 将旧数组中的元素赋值到新的数组中.</li></ol><h4 id="get-K-key-方法主要执行过程"><a href="#get-K-key-方法主要执行过程" class="headerlink" title="get(K key) 方法主要执行过程"></a>get(K key) 方法主要执行过程</h4><p>遍历整个数组<br>1: 如果数组中节点 equals(), key, hash 和传入值都相等, 那么直接返回.<br>2: 如果hash值相等, 节点类型是 TreeNode, 则转由红黑树查找, 否则遍历整个链表查找.</p><h4 id="rehasing-的一些问题"><a href="#rehasing-的一些问题" class="headerlink" title="rehasing 的一些问题."></a>rehasing 的一些问题.</h4><p>当两个线程同时调整HashMap的情况下, 调整链表的next节点时, 可能造成收尾递归, 从而无限循环. 所以在多线程情况下, 推荐使用 ConcurrentHashMap.</p><h2 id="ConcurrentHashMap-的实现"><a href="#ConcurrentHashMap-的实现" class="headerlink" title="ConcurrentHashMap 的实现"></a>ConcurrentHashMap 的实现</h2><p>ConcurrentHashMap的整体结构和HashMap类型, 只不过通过CAS和synchronized来控制并发操作, 整体看来它就是优化和线程安全的HashMap.</p><p>jdk1.7 中, ConcurrentHashMap是由 一个 Segment 数组 和 多个 HashEntry数组组成, Segment 数组就是将一个大表转化为多个小表,  加锁时, 只对一个Segment元素(HashEntry数组) 进行加锁, 减小了锁的粒度, 提高了性能. 其他的数据结构和HashMap实现类似.</p><h4 id="put-K-key-V-value-方法的主要执行过程-1"><a href="#put-K-key-V-value-方法的主要执行过程-1" class="headerlink" title="put(K key, V value) 方法的主要执行过程"></a>put(K key, V value) 方法的主要执行过程</h4><ol><li>首先获取hash值</li><li>如果数据没有初始化, 则调用数组初始化<br>2-1 : 如果已经开始初始化的标志位小于0, 那么当前线程就挂起<br>2-2 : 已经开始初始化的标识位等于0,  将开始初始化的标志位设置为-1, 并开始初始化<br>2-3 : 上面两部就是防止并发初始化.</li><li>没有检测hash冲突那么就直接调用UnSafe的CAS插入该元素<br>3-1 : 如果没有扩容, 直接插入<br>3-2 : 如果容器正在扩容, 那么会调用帮助helpTransfer方法帮助扩容.</li><li>如果检测到hash冲突 ,使用 synchronized 加锁完成 类似 HashMap 碰撞插入的操作.</li><li>检测元素数量是否超过阈值, 进行扩容.</li></ol><h4 id="get-K-key-主要执行过程"><a href="#get-K-key-主要执行过程" class="headerlink" title="get(K key) 主要执行过程"></a>get(K key) 主要执行过程</h4><p>遍历整个数组<br>1: 根据hash值, 找到数组中节点 hash, equals(), key 都相同的元素, 直接返回<br>2: 如果数组查找返回的hash值&lt; 0, 那么数组正在扩容<br>2-1 : 获取到正在扩容的数组, 执行第一步<br>2-2 : 不是首结点, 就向下遍历查找  </p><h4 id="ConcurrentHashMap-改进的总结-1-7-gt-1-8"><a href="#ConcurrentHashMap-改进的总结-1-7-gt-1-8" class="headerlink" title="ConcurrentHashMap 改进的总结 (1.7 -&gt; 1.8)"></a>ConcurrentHashMap 改进的总结 (1.7 -&gt; 1.8)</h4><ol><li>降低了锁的粒度, 由一个Segment(多个HashEntry) -&gt; 一个HashEntry. 提升了性能</li><li>使用内置的synchronized来代替ReentrantLock, 因为ReentrantLock相对synchronized在大量操作时, 会有更多的内存开销, 由于锁粒度下降, ReentrantLock相对synchronized也没有了优势, 且随着synchronized的优化, synchronized的性能也有一定的提升.</li></ol><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>HashTable 虽然是线程安全的, 但是已经不推荐使用, 因为其public方法直接使用synchronized加锁, 相比ConcurrentHashMap, 在多线程操作时, 性能弱了不少.<br>其内部存储就是一个弱化的 HashMap , 通过数组 + 链表存储结构.</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>本质就是一个红黑树, 根据Key的比较器来比较大小进行排序.</p><h2 id="常用Map的继承结构图"><a href="#常用Map的继承结构图" class="headerlink" title="常用Map的继承结构图"></a>常用Map的继承结构图</h2><p><img src="/.io//1.png" alt="细虚线框为接口, 粗虚线框为抽象类, 虚线箭头为继承, 实现箭头为实现"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile的使用方法及一些注意事项</title>
      <link href="/2018/12/23/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2018/12/23/volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="volatile的定义"><a href="#volatile的定义" class="headerlink" title="volatile的定义"></a>volatile的定义</h2><p>volatile是java虚拟机提供的最轻量级的同步机制, 当一个变量定义为volatile之后, 具备两个特性:</p><ol><li>保证此变量对所有线程的可见性, “可见性” 指当一个线程改变了这个变量的值, 新值对于其他线程来说是立即可见的. 普通变量的值在线程之间传递必须通过主内存完成. </li><li>禁止指令重排序优化. 普通的变量只能保证该方法的执行过程中所依赖赋值结果的地方能获取正确的结果, 但不能保证赋值操作的执行顺序与程序代码顺序一致.<br>拓展: </li><li>该变量修饰的变量并不保证原子性</li><li>java中三个实现可见性的关键字: synchronized, final, volatile</li><li>java中两个实现线程之间有序性关键字: volatile(禁止指令重排), synchronized(一个变量在同一时刻只允许一个线程对其进行lock)</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><p>当多个线程依赖一个变量值做状态改变来执行时, 由于测试代码要求要求比较高, 这里只列举样例.</p><pre><code class="java"> volatile boolean stop; //一个线程调用 public void shutdown(){     stop = true; } //多个线程执行doWork方法 public void doWork(){     while(!stop){         // do work     } }</code></pre></li><li><p>禁止指令重排优化, 标准的 双锁检测 单例. 当instance变量被 volatile 修饰以后, 会比没有 volatile 多执行一个内存屏障, 内存屏障能保证多个访问的一致性. </p><pre><code class="java"> public class Singleton { private volatile static Singleton instance; public static Singleton getInstance() {     if (instance == null) {         synchronized (Singleton.class) {             if (instance == null) {                 instance = new Singleton();             }         }     }     return instance; }</code></pre></li></ol><pre><code>## 常见的使用问题1. 上面说到, volatile 是保持多个线程一致性的. 但是并不是说被 volatile 修饰的变量具有原子性.```java    public class VolatileDemo {         static volatile int race = 0;         public static void main(String[] args) {            for (int i = 0; i &lt; 10; i++) {                new Thread(() -&gt; {                    for (int j = 0; j &lt; 10000; j++) {                        race++;                    }                }).start();            }            while (Thread.activeCount() &gt; 1) {                Thread.yield();            }            System.out.println(race);        }     }    //  output: 70254 </code></pre><p>如果需要解决上面的问题, 最简单粗暴的方式就是对 race++ 加锁.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>volatile 是一个在功能上弱化的 synchronized , 但是又有很多不同, 使用时一定要注意场景.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal使用场景及内存泄漏</title>
      <link href="/2018/12/23/ThreadLocal%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
      <url>/2018/12/23/ThreadLocal%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>ThreadLocal官方定义: 该类提供线程局部变量。这些线程局部变量与普通变量的不同，每个线程都有自己独立初始化的变量副本（通过其get或set方法）。<br>如果希望将类的局部变量和线程状态关联(如 user id 或者 transcation id ), 就可以使用ThreadLocal.   </p><h2 id="如何使用它们"><a href="#如何使用它们" class="headerlink" title="如何使用它们"></a>如何使用它们</h2><p>ThreadLocal的简单示例</p><pre><code class="java">private static ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -&gt; &quot;default&quot;);public static void main(String[] args) throws InterruptedException {        threadLocal.set(&quot;in main class&quot;);        System.out.println(&quot;1 &quot; + threadLocal.get());        ExecutorService service = Executors.newFixedThreadPool(1);        service.submit(() -&gt; {            System.out.println(&quot;2 &quot; + threadLocal.get());            threadLocal.set(&quot;in sub thread&quot;);            System.out.println(&quot;3 &quot; + threadLocal.get());        });        service.shutdown();        Thread.sleep(500);        System.out.println(&quot;4 &quot; + threadLocal.get());    }//输出: 1 in main class//2 null//3 in sub thread//4 in main class</code></pre><p>从上面的示例可以看出, 在不同的线程中对ThreadLocal变量进行set和get操作时, 它们的变量是相互独立的.</p><h2 id="为什么ThreadLocal能实现线程变量隔离"><a href="#为什么ThreadLocal能实现线程变量隔离" class="headerlink" title="为什么ThreadLocal能实现线程变量隔离"></a>为什么ThreadLocal能实现线程变量隔离</h2><p>从源码中可知, 每一个Thread内部都有一个ThreadLocalMap, ThreadLocalMap里面 Key是当前ThreadLocal对象, Value是线程对应的变量副本, ThreadLocal所做的事情就是 负责维护每个Thread内部的ThreadLocalMap.<br>ThreadLocal的核心方法</p><pre><code class="java">T get();   // 获取本地线程变量void set(T value) // 设置本地线程变量void remove(); // 移除本地线程变量</code></pre><p>get()的执行内容:<br>    1. 根据Thread.currentThread() 获取当前执行线程信息, 并根据当前线程对象获取该线程的ThreadLocalMap对象<br>    2. 若map不为空, 直接根据当前ThreadLocal对象获取entry, 进入过去value副本并返回<br>    3. 若map为空, 将线程变量副本写入null, 并返回null.</p><p>set()的执行内容:<br>    1. 根据Thread.currentThread() 获取当前执行线程信息, 并根据当前线程对象获取该线程的ThreadLocalMap对象<br>    2. 若map不为空, 将ThreadLocal对象和值写入到当前线程对应的map中.<br>    3. 若map为空, 则需要初始化当前线程的ThreadLocalMap对象, 再写入ThreadLocal和value的副本.</p><p>remove()的执行内容:<br>    1. 获取当前线程的ThreadLocalMap并移除Key为当前ThreadLocal对象的键值对.</p><h2 id="ThreadLocal的问题-可能内存泄漏"><a href="#ThreadLocal的问题-可能内存泄漏" class="headerlink" title="ThreadLocal的问题(可能内存泄漏)"></a>ThreadLocal的问题(可能内存泄漏)</h2><p>当ThreadLocal存储了很多 Key = null 的Entry时, 但长时间不结束当前thread 且不再调用get(), set(), remove() 方法, 那么当ThreadLocal对象被回收后, Key是弱引用也被回收, 但是Value是强引用, 一直不回收, 就容易导致内存泄漏.<br>如何解决该问题: 每次调用完ThreadLocal之后, 都调用remove()方法, 手动销毁数据. </p><h2 id="ThreadLocal带来的好处"><a href="#ThreadLocal带来的好处" class="headerlink" title="ThreadLocal带来的好处"></a>ThreadLocal带来的好处</h2><ol><li>ThreadLocal把操作的数据存储在了线程本地, 直接本地内存读取, 不再需要synchronized等同步的方式修改主内存的数据, 然后再复制到本地内存, 提高了访问效率. 这也是为什么ThreadLocal能解决线程安全的问题.<br>ThreadLocal和线程同步的一些异同: 同步机制采用了“以时间换空间”的方式: 串行访问数据, 并共享对象. 而ThreadLocal采用了“以空间换时间”的方式: 并行访问，独享对象.</li></ol><h2 id="主要应用场景"><a href="#主要应用场景" class="headerlink" title="主要应用场景"></a>主要应用场景</h2><ol><li>在维护每个线程的Session的时候, ThreadLocal能帮助我们在每个线程中独享资源.</li><li>数据库连接在多线程读取的时候, 使用ThreadLocal包装, 能将线程和数据库连接绑定, 方便事务操作.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现线程安全</title>
      <link href="/2018/12/17/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/2018/12/17/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><p>个人理解: 多个线程同时读写某实例对象中同一数据, 可能会造成数据的不正确结果, 这就是线程不安全.<br>在操作数据时, 避免同一数据同一时刻被多个线程共享, 就不会造成数据的混乱, 这就是线程安全.</p><pre><code class="java">//线程不安全简单示例public class ThreadSafeDemo {    int index = 0;    List&lt;String&gt; testList = new ArrayList&lt;String&gt;();    public static void main(String[] args) throws InterruptedException {        new ThreadSafeDemo().test();    }    private void test() throws InterruptedException {        ExecutorService executorService = Executors.newFixedThreadPool(10);        for (int i = 0; i &lt; 100000; i++) {            executorService.submit(() -&gt; {                index++;            });            if (i &lt; 1000) {                executorService.submit(new TestThread(testList));            }        }        executorService.shutdown();        while (!executorService.isTerminated()) {            Thread.sleep(100);        }        System.out.println(&quot;index: &quot; + index);        System.out.println(&quot;testList : &quot; + testList.size());    }}class TestThread implements Runnable {    public List&lt;String&gt; list;    public TestThread(List&lt;String&gt; list) {        this.list = list;    }    @Override    public void run() {        for (int i = 0; i &lt; 100; i++) {            list.add(&quot;&quot;);        }    }}// 多次测试, 两个输出很大几率都不能输出100000</code></pre><h2 id="为什么会造成线程不安全"><a href="#为什么会造成线程不安全" class="headerlink" title="为什么会造成线程不安全"></a>为什么会造成线程不安全</h2><p>一个变量的赋值(i++, list 的add方法)看似是原子操作, 其实是分为三个步骤执行: </p><ol><li>复制源数据, 生成一个数据副本</li><li>操作数据副本</li><li>将副本数据写入源数据<br>当两个线程同时读取 index 时, 都读取到0, 执行index++ 之后, 又写回源数据, 这样本来应该是2 的源数据就变成了1.</li></ol><h2 id="如何实现线程安全"><a href="#如何实现线程安全" class="headerlink" title="如何实现线程安全"></a>如何实现线程安全</h2><p>从上面的示例可以看出, 如果将共享的资源index加锁, 一次只有一个线程访问, 那么就可以解决这个问题.<br>从这个思路出发 可以得出:<br>    1. 直接使用java的 synchronized, lock 等加锁 或者 AtomicInteger 等原子操作类, 让共享资源的访问从并行化变成串行化.<br>    2. 如果是集合类型的并发操作时, 直接使用concurrent包下的 并发集合, 也能达到1的效果.</p><pre><code class="java">public class ThreadSafeDemo {    int index = 0;    ArrayBlockingQueue&lt;String&gt; testList = new ArrayBlockingQueue&lt;String&gt;(100000);    private static final Object objLock = new Object();    public static void main(String[] args) throws InterruptedException {        new ThreadSafeDemo().test();    }    private void test() throws InterruptedException {        ExecutorService executorService = Executors.newFixedThreadPool(10);        for (int i = 0; i &lt; 100000; i++) {            executorService.submit(() -&gt; {                synchronized (objLock) {                    index++;                }            });            if (i &lt; 1000) {                executorService.submit(new TestThread(testList));            }        }        executorService.shutdown();        while (!executorService.isTerminated()) {            Thread.sleep(100);        }        System.out.println(&quot;index: &quot; + index);        System.out.println(&quot;testList : &quot; + testList.size());    }}class TestThread implements Runnable {    public ArrayBlockingQueue&lt;String&gt; list;    public TestThread(ArrayBlockingQueue&lt;String&gt; list) {        this.list = list;    }    @Override    public void run() {        for (int i = 0; i &lt; 100; i++) {            list.add(&quot;&quot;);        }    }}// 输出都是正确的 100000</code></pre><p>还有另外一种思路, 就是为每个执行的线程单独准备一份源数据, 不去一个线程中共享同一个源数据.<br>    1. 对应的就是 ThreadLocal  类, 将每个线程的数据独立, 分别计算, 排除共享变量.</p><pre><code class="java">public class ThreadLocalTest {    ThreadLocal&lt;String&gt; localString = new ThreadLocal&lt;String&gt;();    public void set() {        localString.set(Thread.currentThread().getName());    }    public String getString() {        return localString.get();    }    public static void main(String[] args) throws InterruptedException {        final ThreadLocalTest test = new ThreadLocalTest();        test.set();        System.out.println(test.getString());        ExecutorService executorService = Executors.newFixedThreadPool(2);        for (int i = 0; i &lt; 2; i++) {            executorService.submit(() -&gt; {                test.set();                System.out.println(test.getString());            });        }        executorService.shutdown();        while (!executorService.isTerminated()) {            Thread.sleep(100);        }        System.out.println(test.getString());    }}// 输出: // main// pool-1-thread-1// pool-1-thread-2// main </code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多线程编程中很容易引入线程安全问题, 在实际开发中必须注意.<br>实际开发中SimpleDataFormat不是一个线程安全的类, 所以不推荐使用静态方法的方式在多线程下访问其 parse() 和 format() 方法, 建议使用 ThreadLocal 或者加锁的方式调用.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread Safe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java线程池</title>
      <link href="/2018/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2018/12/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么叫线程池"><a href="#什么叫线程池" class="headerlink" title="什么叫线程池"></a>什么叫线程池</h2><p>一个线程集合, 统一管理线程的数量, 线程的生命周期, 并尽可能重用池中的线程. 我们常用的数据库连接池也是相同思想的产物.</p><h2 id="为什么使用"><a href="#为什么使用" class="headerlink" title="为什么使用"></a>为什么使用</h2><ol><li>一个线程在创建和销毁时, 非常消耗资源. 为了尽可以减少线程创建和销毁的次数, 多次重用同一线程, 将资源消耗分摊到多个任务上. </li><li>不使用线程池管理线程, 若运行的线程数量过大, 可能会导致系统资源消耗过大, 出现异常.</li></ol><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><ol><li>使用如下方式创建线程池:<pre><code class="java">public ThreadPoolExecutor(int corePoolSize,                       int maximumPoolSize,                       long keepAliveTime,                       TimeUnit unit,                       BlockingQueue&lt;Runnable&gt; workQueue,                       ThreadFactory threadFactory,                       RejectedExecutionHandler handler)//静态包装后的常用线程池方法Executors.newSingleThreadExecutor(); Executors.newFixedThreadExecutor(int nthreads);Executors.newCachedThreadExecutor(); </code></pre></li><li>静态方法含义</li></ol><ul><li>Executors.newSingleThreadExecutor(): 创建一个线程池, 但只包含一个线程, 单线程执行所有任务, 若该线程异常结束, 重启一个新线程. </li><li>Executors.newFixedThreadExecutor(int nthreads): 创建一个线程池, 添加一个任务创建一个线程, 直到线程数量等于最大线程数, 线程数则保持不变. 若有线程异常结束, 则重启一个新线程.</li><li>Executors.newCachedThreadExecutor(): 创建一个线程池, 线程数量由jvm和执行的任务量决定, 任务增加时, 自动创建, 线程空闲超时(60秒)后, 自动回收. </li></ul><h2 id="深入参数分析"><a href="#深入参数分析" class="headerlink" title="深入参数分析"></a>深入参数分析</h2><ol><li>线程池的接口/类继承结构:<br>ThreadPoolExecutor -&gt; AbstractExecutorService -&gt; ExecutorService -&gt; Executor<br>Executors 是ThreadPoolExecutor工厂方法实现.</li><li>ThreadPoolExecutor 完整签名 参数讲解:</li></ol><ul><li>corePoolSize: 线程池中所保存的线程数量(包括空闲线程)</li><li>maximumPoolSize: 线程池中所允许的最大线程</li><li>keepAliveTime: 当线程数大于核心数时, 销毁线程的超时时间</li><li>unit: keepAliveTime 的时间单位</li><li>workQueue: 保存待执行的任务的任务队列</li><li>threadFactory: 执行创建线程时所使用的工厂类</li><li>handler: 拒绝执行的任务的处理类</li></ul><ol start="3"><li><p>线程池线程创建逻辑</p><ol><li>当运行线程数 &lt; corePoolSize 时: 直接添加新线程执行任务</li><li>当任务队列满, 运行线程数 &gt;= corePoolSize且 &lt; maximumPoolSize 时: 创建新线程执行任务.</li><li>当任务队列满, 运行线程数 &gt;= corePoolSize且 &gt;= maximumPoolSize 时: 执行拒绝策略</li></ol></li><li><p>线程池线程超时逻辑</p><ol><li>当线程池中线程保持 keepAliveTime 时间后, 自动销毁, 超时时间的单位由 unit 决定.</li></ol></li><li><p>任务队列的类型</p><ol><li>ArrayBlockQueue: 有界队列, 可以防止资源耗尽, 但是难以调优, 不推荐使用.</li><li>LinkedBlockQueue: 无界队列, 任务之间单独执行, 不相互影响.</li><li>SynchronousQueue: 直接提交队列, 不保存任务, 直接提交线程. 但是每次插入必须等待另一个线程移除操作, 否则一直阻塞.</li></ol></li><li><p>拒绝任务执行策略</p><ol><li>CallerRunsPolicy: 直接调用线程运行该任务. 该策略觉得该任务还可以再抢救. 一般会使用执行该execute的线程执行任务</li><li>AbortPolicy: 丢弃任务, 抛出异常</li><li>DiscardPolicy: 直接丢弃任务, 但是不抛出异常</li><li>DiscardOldestPolicy: 将队列首部的旧任务剔除, 执行该任务. 请小心使用该策略.</li></ol></li><li><p>静态方法的默认实现及输出演示:</p><ol><li><p>Executors.newSingleThreadExecutor() : 内部调用 new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<runnable>());</runnable></p><pre><code class="java">ExecutorService executor = Executors.newSingleThreadExecutor();for (int i = 0; i &lt; 4; i++) { final int index = i; executor.execute(() -&gt; {     System.out.print(Integer.toString(index) + Thread.currentThread().getId() + &quot; &quot;);     try {         Thread.sleep(1000);     } catch (InterruptedException e) {         e.printStackTrace();     } });}executor.shutdown();// 输出:  013 113 213 313// 说明结果是同一线程, 顺序执行的</code></pre></li><li><p>Executors.newFixedThreadExecutor(int nthreads) : 内部调用 new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<runnable>());</runnable></p><pre><code class="java">ExecutorService executor = Executors.newFixedThreadPool(2);for (int i = 0; i &lt; 4; i++) { final int index = i; executor.execute(() -&gt; {     System.out.print(Integer.toString(index) + Thread.currentThread().getId() + &quot; &quot;);     try {         Thread.sleep(100);     } catch (InterruptedException e) {         e.printStackTrace();     } });}executor.shutdown();// 输出:  011 112 211 312// 说明结果是两个线程, 独立顺序执行的</code></pre></li><li><p>Executors.newCachedThreadExecutor() : 内部调用 new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<runnable>());</runnable></p><pre><code class="java">ExecutorService executor = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 4; i++) {     final int index = i;     executor.execute(() -&gt; {         System.out.print(Integer.toString(index) + Thread.currentThread().getId() + &quot; &quot;);         try {             Thread.sleep(100);         } catch (InterruptedException e) {             e.printStackTrace();         }     }); } executor.shutdown();// 输出:  011 112 213 314 // 说明结果是多个线程, 独立顺序执行的</code></pre></li></ol></li></ol><h2 id="如何配置线程池大小"><a href="#如何配置线程池大小" class="headerlink" title="如何配置线程池大小"></a>如何配置线程池大小</h2><ol><li>cpu密集型任务: 参考值 n(cpu数量) + 1</li><li>io密集型任务 : 参考值 2 * n(cpu数量)</li><li>参数敏感时需要根据实际情况进行测试, 再具体调整参数</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>推荐使用系统自带的 newSingleThreadExecutor(), newFixedThreadExecutor(), newCachedThreadExecutor() 三个创建线程池的静态方法创建线程, 能满足绝大部分情况.</li><li>自定义参数实现:<ol><li>若对执行时间和顺序有要求, 建议使用优先级队列.</li><li>若任务较多可能超过系统限制, 建议使用有界队列.</li><li>实际情况建议多测试, 具体调整参数.</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
            <tag> Thread Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL字段到底推不推荐使用null值</title>
      <link href="/2018/12/14/MySQL%E5%AD%97%E6%AE%B5%E5%88%B0%E5%BA%95%E6%8E%A8%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8null%E5%80%BC/"/>
      <url>/2018/12/14/MySQL%E5%AD%97%E6%AE%B5%E5%88%B0%E5%BA%95%E6%8E%A8%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8null%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="一-总结结论"><a href="#一-总结结论" class="headerlink" title="一 总结结论"></a>一 总结结论</h2><p>不推荐在任何环境使用null值填充字段</p><h2 id="二-原因分析"><a href="#二-原因分析" class="headerlink" title="二 原因分析"></a>二 原因分析</h2><h3 id="为什么会有人使用"><a href="#为什么会有人使用" class="headerlink" title="为什么会有人使用"></a>为什么会有人使用</h3><ol><li>创建数据库时, 为了以后数据插入方便, 省去中间的校验过程, 方便快捷, 总结就是 图省事.</li><li>创建默认表时sql语句不规范, 使用默认参数, 总结就是 能力不足.</li><li>项目数据迁移时为了在数据层面兼容老数据(项目中实际遇到).</li></ol><h3 id="不推荐理由"><a href="#不推荐理由" class="headerlink" title="不推荐理由"></a>不推荐理由</h3><ol><li>从代码编写角度分许, 数据插入的时候, 的确可以带来方便, 但是在读取数据的时候, 会带来大量的数据非空检查, 否则抛出NullPointException.</li><li>从数据库字段长度占用角度分析, 相同长度字段, null 比 非null 存储空间长度占用多1个字节, 因为需要一个额外字段判断是否是null值.</li><li>从sql语句查询角度分析, null值列和其他列进行操作可能引发错误.</li></ol><h3 id="理由佐证"><a href="#理由佐证" class="headerlink" title="理由佐证"></a>理由佐证</h3><ol><li>理由1不需要佐证</li><li>首先新建环境, sql语句如下<pre><code class="sql">create table nulltesttable( id int primary key, name_not_null varchar(10) not null, name_null varchar(10)) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1;alter table nulltesttable add index idx_nulltesttable_name_not_null(name_not_null);alter table nulltesttable add index idx_nulltesttable_name_null(name_null);</code></pre></li></ol><p>explain select * from nulltesttable where name_not_null=’name’; // explain1<br>explain select * from nulltesttable where name_null=’name’; // explain2</p><pre><code>从sql 执行可以看出, explain1中 key_len = 32, explain2中 key_len = 33explain1的32 由来: 10(字段长度) * 3(utf8字符编码占用长度) + 2(varchar标识为变长占用长度)explain2的32 由来: 10(字段长度) * 3(utf8字符编码占用长度) + 2(varchar标识为变长占用长度) + 1(null标识位占用长度)3. 两个字符串拼接, 如果包含null值, 则返回结果为null. ```sqlinsert into nulltesttable(id,name_not_null,name_null) values(1,&#39;one&#39;,null);insert into nulltesttable(id,name_not_null,name_null) values(2,&#39;two&#39;,&#39;three&#39;);select concat(name_not_null,name_null) from nulltesttable where id = 1; -- out: nullselect concat(name_not_null,name_null) from nulltesttable where id = 2; -- out: twothree</code></pre><ol start="4"><li>如果字段允许null值, 且这个字段被索引. 如下的查询可能会返回不正确的结果<pre><code class="sql">select * from nulltesttable where name_null &lt;&gt; &#39;three&#39; -- out: nullselect count(name_null) from nulltesttable -- out: 1 </code></pre></li></ol><h2 id="三-使用建议"><a href="#三-使用建议" class="headerlink" title="三 使用建议"></a>三 使用建议</h2><ol><li>数据库中null值字段, null值使用一个意义字符来代替(大部分可以使用””或者0来代替), 能极大的提升代码的可读性和可维护性，并避免上面的问题.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
